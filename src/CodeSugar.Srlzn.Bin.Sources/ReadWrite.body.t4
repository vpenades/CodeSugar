        

        #region specialised - packed size

        /// <summary>
        /// Packs a <see cref="UInt64"/> value.
        /// </summary>
        /// <param name="target">The target memory.</param>
        /// <param name="value">The value to pack.</param>
        /// <remarks>
        /// Stores the sign in the lowest bit to allow the same encoding strength on positive and negative values.
        /// </remarks>
        public static WRITEABLEBLOCK WritePackedS64(this WRITEABLEBLOCK target, long value)
        {
            var uval = (ulong)value;

            if (value >= 0)
            {
                uval <<= 1;
            }
            else
            {
                uval = ~uval;
                uval <<= 1;
                uval |= 1;
            }

            return WritePackedU64(target, uval);
        }

        /// <summary>
        /// Packs a <see cref="UInt64"/> value.
        /// </summary>
        /// <param name="target">The target memory.</param>
        /// <param name="uValue">The value to pack.</param>
        /// <remarks>
        /// This is equivalent to <see cref="BinaryWriter.Write7BitEncodedInt64(long)"/>
        /// </remarks>
        public static WRITEABLEBLOCK WritePackedU64(this WRITEABLEBLOCK target, ulong uValue)
        {
            // if (target.Length < 10) throw new ArgumentException(nameof(target), "too short");

            // Write out an int 7 bits at a time. The high bit of the byte,
            // when on, tells reader to continue reading more bytes.
            //
            // Using the constants 0x7F and ~0x7F below offers smaller
            // codegen than using the constant 0x80.            

            

            while (uValue > 0x7Fu)
            {
                target = target.WriteU8( (byte)((uint)uValue | ~0x7Fu) );
                uValue >>= 7;
            }

            return target.WriteU8( (byte)uValue );
        }

        /// <summary>
        /// Unpacks a <see cref="Int64"/> value.
        /// </summary>
        /// <param name="target">The target memory.</param>
        /// <param name="result">the read value</param>
        /// <returns>The target memory with pointer moved forward.</returns>
        /// <remarks>
        /// Stores the sign in the lowest bit to allow the same encoding strength on positive and negative values.
        /// </remarks>        
        public static READABLEBLOCK ReadPackedS64(this READABLEBLOCK source, out long result)
        {
            source = ReadPackedU64(source, out var uval);
            var neg = (uval & 1) != 0;
            uval >>= 1;
            if (neg) uval = ~uval;
            result = (long)uval;
            return source;
        }

        /// <summary>
        /// Unpacks a <see cref="UInt64"/> value.
        /// </summary>
        /// <param name="source">The source memory.</param>
        /// <param name="result">the read value</param>
        /// <returns>The source memory with pointer moved forward.</returns>
        /// <remarks>
        /// This is equivalent to <see cref="BinaryReader.Read7BitEncodedInt64"/>
        /// </remarks>        
        public static READABLEBLOCK ReadPackedU64(this READABLEBLOCK source, out ulong result)
        {
            result = 0;
            byte readValue;            

            // Read the integer 7 bits at a time. The high bit
            // of the byte when on means to continue reading more bytes.
            //
            // There are two failure cases: we've read more than 10 bytes,
            // or the tenth byte is about to cause integer overflow.
            // This means that we can read the first 9 bytes without
            // worrying about integer overflow.

            const int MaxBytesWithoutOverflow = 9;
            for (int shift = 0; shift < MaxBytesWithoutOverflow * 7; shift += 7)
            {                
                source = source.ReadU8(out readValue);
                
                result |= (readValue & 0x7Ful) << shift;

                if (readValue <= 0x7Fu)
                {
                    return source; // early exit
                }
            }

            // Read the 10th byte. Since we already read 63 bits,
            // the value of this byte must fit within 1 bit (64 - 63),
            // and it must not have the high bit set.

            source = source.ReadU8(out readValue);            
            if (readValue > 0b_1u)
            {
                throw new FormatException("invalid encoding");
            }

            result |= (ulong)readValue << (MaxBytesWithoutOverflow * 7);
            return source;
        }

        #endregion        

        #region specialised - time

        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        public static WRITEABLEBLOCK WriteLeTimeSpan(this WRITEABLEBLOCK target, TimeSpan value) => WriteEndian<long>(target, value.Ticks, false);
        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        public static WRITEABLEBLOCK WriteBeTimeSpan(this WRITEABLEBLOCK target, TimeSpan value) => WriteEndian<long>(target, value.Ticks, true);

        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        public static READABLEBLOCK ReadLeTimeSpan(this READABLEBLOCK source, out TimeSpan value)
        {
            source = ReadEndian<long>(source, out var val, false);
            value = new TimeSpan(val);
            return source;
        }

        /// <summary>Reads BIG endian value</summary>
        /// <returns>Next read context</returns>
        public static READABLEBLOCK ReadBeTimeSpan(this READABLEBLOCK source, out TimeSpan value)
        {
            source = ReadEndian<long>(source, out var val, true);
            value = new TimeSpan(val);
            return source;
        }

        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        public static WRITEABLEBLOCK WriteLeDateTime(this WRITEABLEBLOCK target, DateTime value) => WriteEndian<long>(target, value.ToBinary(), false);
        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        public static WRITEABLEBLOCK WriteBeDateTime(this WRITEABLEBLOCK target, DateTime value) => WriteEndian<long>(target, value.ToBinary(), true);

        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        public static READABLEBLOCK ReadLeDateTime(this READABLEBLOCK source, out DateTime value)
        {
            source = ReadEndian<long>(source, out var val, false);
            value = DateTime.FromBinary(val);
            return source;
        }

        /// <summary>Reads BIG endian value</summary>
        /// <returns>Next read context</returns>
        public static READABLEBLOCK ReadBeDateTime(this READABLEBLOCK source, out DateTime value)
        {
            source = ReadEndian<long>(source, out var val, true);
            value = DateTime.FromBinary(val);
            return source;
        }

        public static WRITEABLEBLOCK WriteDateTimeOffset(this WRITEABLEBLOCK target, DateTimeOffset value, bool targetIsBigEndian = false)
        {
            target = WriteEndian(target, value.DateTime.ToBinary(), targetIsBigEndian);
            target = WriteEndian(target, value.Offset.Ticks, targetIsBigEndian);
            return target;
        }

        public static READABLEBLOCK ReadDateTimeOffset(this READABLEBLOCK source, out DateTimeOffset value, bool sourceIsBigEndian = false)
        {
            source = ReadEndian(source, out long t, sourceIsBigEndian);
            source = ReadEndian(source, out long o, sourceIsBigEndian);
            value = new DateTimeOffset(DateTime.FromBinary(t), new TimeSpan(o));
            return source;
        }        

        #endregion

        #region text

        /// <summary>
        /// Writes a string.
        /// </summary>
        /// <param name="target">The target stream.</param>
        /// <param name="text">The text to write.</param>
        /// <param name="encoding">The text encoding.</param>
        /// <remarks>
        /// This is equivalent to <see cref="BinaryWriter.Write(string)"/>
        /// </remarks>
        public static WRITEABLEBLOCK WriteString(this WRITEABLEBLOCK target, string text, System.Text.Encoding encoding = null)
        {
            encoding ??= System.Text.Encoding.UTF8;

            text ??= string.Empty;

            var chars = text.ToCharArray();

            var blen = encoding.GetByteCount(chars);
            
            if (blen < 256)
            {
                Span<byte> span = stackalloc byte[blen];
                var xlen = encoding.GetBytes(chars, span);
                span = span.Slice(0, xlen);

                target = WritePackedU64(target, (ulong)span.Length);
                <#=BYTEWRITER#>

                return target;
            }            
            
            var buf = encoding.GetBytes(chars);

            target = WritePackedU64(target, (ulong)buf.Length);            
            target = WriteBytes(target, buf);

            return target;
        }

        /// <summary>
        /// Read a string.
        /// </summary>
        /// <param name="source">The source stream.</param>
        /// <param name="encoding">The text encoding.</param>
        /// <returns>The string being read.</returns>
        /// <remarks>
        /// This is equivalent to <see cref="BinaryReader.ReadString"/>
        /// </remarks>
        public static READABLEBLOCK ReadString(this READABLEBLOCK source, out string value, System.Text.Encoding encoding = null)
        {
            encoding ??= System.Text.Encoding.UTF8;

            value = string.Empty;

            // Length of the string in bytes, not chars
            source = ReadPackedU64(source, out var blen);
            if (blen > int.MaxValue) throw new IOException("invalid string length");
            if (blen == 0) return source;

            if (blen < 256)
            {
                Span<byte> span = stackalloc byte[(int)blen];
                <#=BYTEREADER#>

                var s = encoding.GetString(span);

                value = string.IsInterned(s) ?? s;
            }
            else
            {
                var span = new byte[(int)blen];
                source = ReadBytes(source, span);                

                var s = encoding.GetString(span);

                value = string.IsInterned(s) ?? s;
            }

            return source;
        }


        #endregion

        #region collections

        public delegate WRITEABLEBLOCK ItemWrite<#=CONTEXTNAME#>Delegate<T>(WRITEABLEBLOCK source, T item);
        public delegate READABLEBLOCK ItemRead<#=CONTEXTNAME#>Delegate<T>(READABLEBLOCK source, ref T item);

        public static WRITEABLEBLOCK WriteList<T>(this WRITEABLEBLOCK target, IReadOnlyList<T> source, ItemWrite<#=CONTEXTNAME#>Delegate<T> lambda)
        {
            if (source == null) return target.WritePackedU64(0);

            target = target.WritePackedU64( (uint)source.Count);

            foreach(var item in source)
            {
                target = lambda(target, item);
            }

            return target;
        }

        public static READABLEBLOCK ReadList<T>(this READABLEBLOCK source, ref List<T> result, ItemRead<#=CONTEXTNAME#>Delegate<T> lambda)
        {
            source = source.ReadPackedU64(out var count);
            if (count == 0) return source;

            result ??= new List<T>((int)count);

            for(int i=0; i < (int)count; ++i)
            {
                T item = default;
                source = lambda(source, ref item);
                result.Add(item);
            }            

            return source;
        }

        public static READABLEBLOCK ReadList<T>(this READABLEBLOCK source, IList<T> result, ItemRead<#=CONTEXTNAME#>Delegate<T> lambda)
        {
            source = source.ReadPackedU64(out var count);
            if (count == 0) return source;            

            for(int i=0; i < (int)count; ++i)
            {
                T item = default;
                source = lambda(source, ref item);
                result.Add(item);
            }            

            return source;
        }

        public static READABLEBLOCK ReadList<T>(this READABLEBLOCK source, out T[] result, ItemRead<#=CONTEXTNAME#>Delegate<T> lambda)
        {
            source = source.ReadPackedU64(out var count);
            if (count == 0) { result = null; return source; }

            var array = new T[(int)count];

            for(int i=0; i < array.Length; ++i)
            {
                source = lambda(source, ref array[i]);
            }

            result = array;

            return source;
        }

        public static WRITEABLEBLOCK WriteDictionary<T>(this WRITEABLEBLOCK target, IReadOnlyDictionary<string, T> source, ItemWrite<#=CONTEXTNAME#>Delegate<T> lambda)
        {
            if (source == null) return target.WritePackedU64(0);

            target = target.WritePackedU64( (uint)source.Count);

            foreach(var (key,item) in source)
            {
                target = WriteString(target, key);
                target = lambda(target, item);
            }

            return target;
        }

        public static READABLEBLOCK ReadDictionary<T>(this READABLEBLOCK source, ref Dictionary<string, T> result, ItemRead<#=CONTEXTNAME#>Delegate<T> lambda)
        {
            result ??= new Dictionary<string,T>();
            return ReadDictionary(source, result, lambda);
        }

        public static READABLEBLOCK ReadDictionary<T>(this READABLEBLOCK source, IDictionary<string, T> result, ItemRead<#=CONTEXTNAME#>Delegate<T> lambda)
        {
            source = source.ReadPackedU64(out var count);
            if (count == 0) return source;            

            for(int i=0; i < (int)count; ++i)
            {
                T item = default;
                source = source.ReadString(out var key);
                source = lambda(source, ref item);
                result[key] = item;
            }            

            return source;
        }

        #endregion
    