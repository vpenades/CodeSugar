// <auto-generated />
// Copyright (c) CodeSugar 2024 Vicente Penades

using System;
using System.IO;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;


#nullable disable

using _READABLEBLOCK = System.Collections.Generic.IEnumerator<byte>;
using _WRITEABLEBLOCK = System.IProgress<byte>; 

#if CODESUGAR_USECODESUGARNAMESPACE
namespace CodeSugar
#elif CODESUGAR_USESYSTEMNAMESPACE
namespace System
#else
namespace $rootnamespace$
#endif
{
    static partial class CodeSugarForSerialization
    {

        #region specialised - Numerics

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeVector2([NotNull] this _WRITEABLEBLOCK target, System.Numerics.Vector2 value)
        {
            return target.WriteLeF32(value.X).WriteLeF32(value.Y);
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadLeVector2([NotNull] this _READABLEBLOCK source, out System.Numerics.Vector2 value)
        {
            return source.ReadLeF32(out value.X).ReadLeF32(out value.Y);
        }

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeVector3([NotNull] this _WRITEABLEBLOCK target, System.Numerics.Vector3 value)
        {
            return target.WriteLeF32(value.X).WriteLeF32(value.Y).WriteLeF32(value.Z);
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadLeVector3([NotNull] this _READABLEBLOCK source, out System.Numerics.Vector3 value)
        {
            return source.ReadLeF32(out value.X).ReadLeF32(out value.Y).ReadLeF32(out value.Z);
        }

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeVector4([NotNull] this _WRITEABLEBLOCK target, System.Numerics.Vector4 value)
        {
            return target.WriteLeF32(value.X).WriteLeF32(value.Y).WriteLeF32(value.Z).WriteLeF32(value.W);
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadLeVector4([NotNull] this _READABLEBLOCK source, out System.Numerics.Vector4 value)
        {
            return source.ReadLeF32(out value.X).ReadLeF32(out value.Y).ReadLeF32(out value.Z).ReadLeF32(out value.W);
        }

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeQuaternion([NotNull] this _WRITEABLEBLOCK target, System.Numerics.Quaternion value)
        {
            return target.WriteLeF32(value.X).WriteLeF32(value.Y).WriteLeF32(value.Z).WriteLeF32(value.W);
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadLeQuaternion([NotNull] this _READABLEBLOCK source, out System.Numerics.Quaternion value)
        {
            return source.ReadLeF32(out value.X).ReadLeF32(out value.Y).ReadLeF32(out value.Z).ReadLeF32(out value.W);
        }        

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeMatrix3x2([NotNull] this _WRITEABLEBLOCK target, System.Numerics.Matrix3x2 value)
        {
            return target
                .WriteLeF32(value.M11).WriteLeF32(value.M12)
                .WriteLeF32(value.M21).WriteLeF32(value.M22)
                .WriteLeF32(value.M31).WriteLeF32(value.M32);
                
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadLeMatrix3x2([NotNull] this _READABLEBLOCK source, out System.Numerics.Matrix3x2 value)
        {
            return source
                .ReadLeF32(out value.M11).ReadLeF32(out value.M12)
                .ReadLeF32(out value.M21).ReadLeF32(out value.M22)
                .ReadLeF32(out value.M31).ReadLeF32(out value.M32);
        }

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeMatrix4x4([NotNull] this _WRITEABLEBLOCK target, System.Numerics.Matrix4x4 value)
        {
            return target
                .WriteLeF32(value.M11).WriteLeF32(value.M12).WriteLeF32(value.M13).WriteLeF32(value.M14)
                .WriteLeF32(value.M21).WriteLeF32(value.M22).WriteLeF32(value.M23).WriteLeF32(value.M24)
                .WriteLeF32(value.M31).WriteLeF32(value.M32).WriteLeF32(value.M33).WriteLeF32(value.M34)
                .WriteLeF32(value.M41).WriteLeF32(value.M42).WriteLeF32(value.M43).WriteLeF32(value.M44);
                
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadLeMatrix4x4([NotNull] this _READABLEBLOCK source, out System.Numerics.Matrix4x4 value)
        {
            return source
                .ReadLeF32(out value.M11).ReadLeF32(out value.M12).ReadLeF32(out value.M13).ReadLeF32(out value.M14)
                .ReadLeF32(out value.M21).ReadLeF32(out value.M22).ReadLeF32(out value.M23).ReadLeF32(out value.M24)
                .ReadLeF32(out value.M31).ReadLeF32(out value.M32).ReadLeF32(out value.M33).ReadLeF32(out value.M34)
                .ReadLeF32(out value.M41).ReadLeF32(out value.M42).ReadLeF32(out value.M43).ReadLeF32(out value.M44);
        }   

        #endregion
        
        #region primitives

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteBool([NotNull] this _WRITEABLEBLOCK source, bool value) { return WriteU8(source, value ? (Byte)255 : (Byte)0); }

        [return: NotNull]
        public static _READABLEBLOCK ReadBool([NotNull] this _READABLEBLOCK source, out bool value)
        {
            source = ReadU8(source, out var bval);
            value = bval != 0;
            return source;
        }

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteU8([NotNull] this _WRITEABLEBLOCK source, Byte value) { return WritePlatform<Byte>(source, value); }

        [return: NotNull]
        public static _READABLEBLOCK ReadU8([NotNull] this _READABLEBLOCK source, out Byte value) { return ReadPlatform<Byte>(source, out value); }

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteS8([NotNull] this _WRITEABLEBLOCK source, SByte value) { return WritePlatform<Byte>(source, (Byte)value); }

        [return: NotNull]
        public static _READABLEBLOCK ReadS8([NotNull] this _READABLEBLOCK source, out SByte value) { source = ReadPlatform<Byte>(source, out var uvalue); value = (SByte)uvalue; return source; }
        
        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeS16([NotNull] this _WRITEABLEBLOCK target, Int16 value) => WriteEndian(target, value, false);

        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeU16([NotNull] this _WRITEABLEBLOCK target, UInt16 value) => WriteEndian(target, value, false);

        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeS32([NotNull] this _WRITEABLEBLOCK target, Int32 value) => WriteEndian(target, value, false);

        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeU32([NotNull] this _WRITEABLEBLOCK target, UInt32 value) => WriteEndian(target, value, false);

        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeS64([NotNull] this _WRITEABLEBLOCK target, Int64 value) => WriteEndian(target, value, false);

        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeU64([NotNull] this _WRITEABLEBLOCK target, UInt64 value) => WriteEndian(target, value, false);

        #if NET5_0_OR_GREATER
        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeF16([NotNull] this _WRITEABLEBLOCK target, Half value) => WriteEndian(target, value, false);
        #endif

        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeF32([NotNull] this _WRITEABLEBLOCK target, Single value) => WriteEndian(target, value, false);

        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeF64([NotNull] this _WRITEABLEBLOCK target, Double value) => WriteEndian(target, value, false);


        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteBeS16([NotNull] this _WRITEABLEBLOCK target, Int16 value) => WriteEndian(target, value, true);

        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteBeU16([NotNull] this _WRITEABLEBLOCK target, UInt16 value) => WriteEndian(target, value, true);

        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteBeS32([NotNull] this _WRITEABLEBLOCK target, Int32 value) => WriteEndian(target, value, true);

        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteBeU32([NotNull] this _WRITEABLEBLOCK target, UInt32 value) => WriteEndian(target, value, true);

        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteBeS64([NotNull] this _WRITEABLEBLOCK target, Int64 value) => WriteEndian(target, value, true);

        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteBeU64([NotNull] this _WRITEABLEBLOCK target, UInt64 value) => WriteEndian(target, value, true);

        #if NET5_0_OR_GREATER
        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteBeF16(this _WRITEABLEBLOCK target, Half value) => WriteEndian(target, value, true);
        #endif

        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteBeF32(this _WRITEABLEBLOCK target, Single value) => WriteEndian(target, value, true);

        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteBeF64(this _WRITEABLEBLOCK target, Double value) => WriteEndian(target, value, true);


        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadLeS16(this _READABLEBLOCK source, out Int16 value) => ReadEndian(source, out value, false);

        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadLeU16(this _READABLEBLOCK source, out UInt16 value) => ReadEndian(source, out value, false);

        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadLeS32(this _READABLEBLOCK source, out Int32 value) => ReadEndian(source, out value, false);

        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadLeU32(this _READABLEBLOCK source, out UInt32 value) => ReadEndian(source, out value, false);

        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadLeS64(this _READABLEBLOCK source, out Int64 value) => ReadEndian(source, out value, false);

        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadLeU64(this _READABLEBLOCK source, out UInt64 value) => ReadEndian(source, out value, false);

        #if NET5_0_OR_GREATER
        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadLeF16(this _READABLEBLOCK source, out Half value) => ReadEndian(source, out value, false);
        #endif

        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadLeF32(this _READABLEBLOCK source, out Single value) => ReadEndian(source, out value, false);

        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadLeF64(this _READABLEBLOCK source, out Double value) => ReadEndian(source, out value, false);


        /// <summary>Reads BIG endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadBeS16(this _READABLEBLOCK source, out Int16 value) => ReadEndian(source, out value, true);

        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadBeU16(this _READABLEBLOCK source, out UInt16 value) => ReadEndian(source, out value, true);

        /// <summary>Reads BIG endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadBeS32(this _READABLEBLOCK source, out Int32 value) => ReadEndian(source, out value, true);

        /// <summary>Reads BIG endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadBeU32(this _READABLEBLOCK source, out UInt32 value) => ReadEndian(source, out value, true);

        /// <summary>Reads BIG endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadBeS64(this _READABLEBLOCK source, out Int64 value) => ReadEndian(source, out value, true);

        /// <summary>Reads BIG endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadBeU64(this _READABLEBLOCK source, out UInt64 value) => ReadEndian(source, out value, true);

        #if NET5_0_OR_GREATER
        /// <summary>Reads BIG endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadBeF16(this _READABLEBLOCK source, out Half value) => ReadEndian(source, out value, true);
        #endif

        /// <summary>Reads BIG endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadBeF32(this _READABLEBLOCK source, out Single value) => ReadEndian(source, out value, true);

        /// <summary>Reads BIG endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadBeF64(this _READABLEBLOCK source, out Double value) => ReadEndian(source, out value, true);        

        #endregion
        

        #region specialised - packed size

        /// <summary>
        /// Packs a <see cref="UInt64"/> value.
        /// </summary>
        /// <param name="target">The target memory.</param>
        /// <param name="value">The value to pack.</param>
        /// <remarks>
        /// Stores the sign in the lowest bit to allow the same encoding strength on positive and negative values.
        /// </remarks>
        [return: NotNull]
        public static _WRITEABLEBLOCK WritePackedS64([NotNull] this _WRITEABLEBLOCK target, long value)
        {
            var uval = (ulong)value;

            if (value >= 0)
            {
                uval <<= 1;
            }
            else
            {
                uval = ~uval;
                uval <<= 1;
                uval |= 1;
            }

            return WritePackedU64(target, uval);
        }

        /// <summary>
        /// Packs a <see cref="UInt64"/> value.
        /// </summary>
        /// <param name="target">The target memory.</param>
        /// <param name="uValue">The value to pack.</param>
        /// <remarks>
        /// This is equivalent to <see cref="BinaryWriter.Write7BitEncodedInt64(long)"/>
        /// </remarks>
        [return: NotNull]
        public static _WRITEABLEBLOCK WritePackedU64([NotNull] this _WRITEABLEBLOCK target, ulong uValue)
        {
            // if (target.Length < 10) throw new ArgumentException(nameof(target), "too short");

            // Write out an int 7 bits at a time. The high bit of the byte,
            // when on, tells reader to continue reading more bytes.
            //
            // Using the constants 0x7F and ~0x7F below offers smaller
            // codegen than using the constant 0x80.            

            

            while (uValue > 0x7Fu)
            {
                target = target.WriteU8( (byte)((uint)uValue | ~0x7Fu) );
                uValue >>= 7;
            }

            return target.WriteU8( (byte)uValue );
        }

        /// <summary>
        /// Unpacks a <see cref="Int64"/> value.
        /// </summary>
        /// <param name="target">The target memory.</param>
        /// <param name="result">the read value</param>
        /// <returns>The target memory with pointer moved forward.</returns>
        /// <remarks>
        /// Stores the sign in the lowest bit to allow the same encoding strength on positive and negative values.
        /// </remarks>
        [return: NotNull]
        public static _READABLEBLOCK ReadPackedS64([NotNull] this _READABLEBLOCK source, out long result)
        {
            source = ReadPackedU64(source, out var uval);
            var neg = (uval & 1) != 0;
            uval >>= 1;
            if (neg) uval = ~uval;
            result = (long)uval;
            return source;
        }

        /// <summary>
        /// Unpacks a <see cref="UInt64"/> value.
        /// </summary>
        /// <param name="source">The source memory.</param>
        /// <param name="result">the read value</param>
        /// <returns>The source memory with pointer moved forward.</returns>
        /// <remarks>
        /// This is equivalent to <see cref="BinaryReader.Read7BitEncodedInt64"/>
        /// </remarks>
        [return: NotNull]
        public static _READABLEBLOCK ReadPackedU64([NotNull] this _READABLEBLOCK source, out ulong result)
        {
            result = 0;
            byte readValue;            

            // Read the integer 7 bits at a time. The high bit
            // of the byte when on means to continue reading more bytes.
            //
            // There are two failure cases: we've read more than 10 bytes,
            // or the tenth byte is about to cause integer overflow.
            // This means that we can read the first 9 bytes without
            // worrying about integer overflow.

            const int MaxBytesWithoutOverflow = 9;
            for (int shift = 0; shift < MaxBytesWithoutOverflow * 7; shift += 7)
            {                
                source = source.ReadU8(out readValue);
                
                result |= (readValue & 0x7Ful) << shift;

                if (readValue <= 0x7Fu)
                {
                    return source; // early exit
                }
            }

            // Read the 10th byte. Since we already read 63 bits,
            // the value of this byte must fit within 1 bit (64 - 63),
            // and it must not have the high bit set.

            source = source.ReadU8(out readValue);            
            if (readValue > 0b_1u)
            {
                throw new FormatException("invalid encoding");
            }

            result |= (ulong)readValue << (MaxBytesWithoutOverflow * 7);
            return source;
        }

        #endregion        

        #region specialised - time

        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeTimeSpan([NotNull] this _WRITEABLEBLOCK target, TimeSpan value) => WriteEndian<long>(target, value.Ticks, false);
        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteBeTimeSpan([NotNull] this _WRITEABLEBLOCK target, TimeSpan value) => WriteEndian<long>(target, value.Ticks, true);

        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadLeTimeSpan([NotNull] this _READABLEBLOCK source, out TimeSpan value)
        {
            source = ReadEndian<long>(source, out var val, false);
            value = new TimeSpan(val);
            return source;
        }

        /// <summary>Reads BIG endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadBeTimeSpan([NotNull] this _READABLEBLOCK source, out TimeSpan value)
        {
            source = ReadEndian<long>(source, out var val, true);
            value = new TimeSpan(val);
            return source;
        }

        /// <summary>Writes little endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeDateTime([NotNull] this _WRITEABLEBLOCK target, DateTime value) => WriteEndian<long>(target, value.ToBinary(), false);
        /// <summary>Writes BIG endian value</summary>
        /// <returns>Next write context</returns>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteBeDateTime([NotNull] this _WRITEABLEBLOCK target, DateTime value) => WriteEndian<long>(target, value.ToBinary(), true);

        /// <summary>Reads little endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadLeDateTime([NotNull] this _READABLEBLOCK source, out DateTime value)
        {
            source = ReadEndian<long>(source, out var val, false);
            value = DateTime.FromBinary(val);
            return source;
        }

        /// <summary>Reads BIG endian value</summary>
        /// <returns>Next read context</returns>
        [return: NotNull]
        public static _READABLEBLOCK ReadBeDateTime([NotNull] this _READABLEBLOCK source, out DateTime value)
        {
            source = ReadEndian<long>(source, out var val, true);
            value = DateTime.FromBinary(val);
            return source;
        }

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteDateTimeOffset([NotNull] this _WRITEABLEBLOCK target, DateTimeOffset value, bool targetIsBigEndian = false)
        {
            target = WriteEndian(target, value.DateTime.ToBinary(), targetIsBigEndian);
            target = WriteEndian(target, value.Offset.Ticks, targetIsBigEndian);
            return target;
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadDateTimeOffset([NotNull] this _READABLEBLOCK source, out DateTimeOffset value, bool sourceIsBigEndian = false)
        {
            source = ReadEndian(source, out long t, sourceIsBigEndian);
            source = ReadEndian(source, out long o, sourceIsBigEndian);
            value = new DateTimeOffset(DateTime.FromBinary(t), new TimeSpan(o));
            return source;
        }        

        #endregion

        #region text

        /// <summary>
        /// Writes a string.
        /// </summary>
        /// <param name="target">The target stream.</param>
        /// <param name="text">The text to write.</param>
        /// <param name="encoding">The text encoding.</param>
        /// <remarks>
        /// This is equivalent to <see cref="BinaryWriter.Write(string)"/>
        /// </remarks>
        [return: NotNull]
        public static _WRITEABLEBLOCK WriteString([NotNull] this _WRITEABLEBLOCK target, string text, System.Text.Encoding encoding = null)
        {
            encoding ??= System.Text.Encoding.UTF8;

            text ??= string.Empty;

            var chars = text.ToCharArray();

            var blen = encoding.GetByteCount(chars);
            
            if (blen < 256)
            {
                Span<byte> span = stackalloc byte[blen];
                var xlen = encoding.GetBytes(chars, span);
                span = span.Slice(0, xlen);

                target = WritePackedU64(target, (ulong)span.Length);
                target = WriteBytes(target, span);

                return target;
            }            
            
            var buf = encoding.GetBytes(chars);

            target = WritePackedU64(target, (ulong)buf.Length);            
            target = WriteBytes(target, buf);

            return target;
        }

        /// <summary>
        /// Read a string.
        /// </summary>
        /// <param name="source">The source stream.</param>
        /// <param name="encoding">The text encoding.</param>
        /// <returns>The string being read.</returns>
        /// <remarks>
        /// This is equivalent to <see cref="BinaryReader.ReadString"/>
        /// </remarks>
        [return: NotNull]
        public static _READABLEBLOCK ReadString([NotNull] this _READABLEBLOCK source, out string value, System.Text.Encoding encoding = null)
        {
            encoding ??= System.Text.Encoding.UTF8;

            value = string.Empty;

            // Length of the string in bytes, not chars
            source = ReadPackedU64(source, out var blen);
            if (blen > int.MaxValue) throw new IOException("invalid string length");
            if (blen == 0) return source;

            if (blen < 256)
            {
                Span<byte> span = stackalloc byte[(int)blen];
                source = ReadBytes(source, span);

                var s = encoding.GetString(span);

                value = string.IsInterned(s) ?? s;
            }
            else
            {
                var span = new byte[(int)blen];
                source = ReadBytes(source, span);                

                var s = encoding.GetString(span);

                value = string.IsInterned(s) ?? s;
            }

            return source;
        }


        #endregion

        #region collections

        public delegate _WRITEABLEBLOCK ItemWriteInterfaceDelegate<T>([NotNull] _WRITEABLEBLOCK source, T item);
        public delegate _READABLEBLOCK ItemReadInterfaceDelegate<T>([NotNull] _READABLEBLOCK source, out T item);

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteList<T>([NotNull] this _WRITEABLEBLOCK target, IReadOnlyList<T> source, ItemWriteInterfaceDelegate<T> lambda)
        {
            if (source == null) return target.WritePackedU64(0);

            target = target.WritePackedU64( (uint)source.Count);

            foreach(var item in source)
            {
                target = lambda(target, item);
            }

            return target;
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadList<T>([NotNull] this _READABLEBLOCK source, ref List<T> result, ItemReadInterfaceDelegate<T> lambda)
        {
            source = source.ReadPackedU64(out var count);
            if (count == 0) return source;

            result ??= new List<T>((int)count);

            for(int i=0; i < (int)count; ++i)
            {                
                source = lambda(source, out var item);
                result.Add(item);
            }            

            return source;
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadList<T>([NotNull] this _READABLEBLOCK source, IList<T> result, ItemReadInterfaceDelegate<T> lambda)
        {
            source = source.ReadPackedU64(out var count);
            if (count == 0) return source;            

            for(int i=0; i < (int)count; ++i)
            {                
                source = lambda(source, out var item);
                result.Add(item);
            }            

            return source;
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadList<T>([NotNull] this _READABLEBLOCK source, out T[] result, ItemReadInterfaceDelegate<T> lambda)
        {
            source = source.ReadPackedU64(out var count);
            if (count == 0) { result = null; return source; }

            var array = new T[(int)count];

            for(int i=0; i < array.Length; ++i)
            {
                source = lambda(source, out var item);
                array[i] = item;
            }

            result = array;

            return source;
        }

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteDictionary<T>([NotNull] this _WRITEABLEBLOCK target, IReadOnlyDictionary<string, T> source, ItemWriteInterfaceDelegate<T> lambda)
        {
            if (source == null) return target.WritePackedU64(0);

            target = target.WritePackedU64( (uint)source.Count);

            foreach(var (key,item) in source)
            {
                target = WriteString(target, key);
                target = lambda(target, item);
            }

            return target;
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadDictionary<T>([NotNull] this _READABLEBLOCK source, ref Dictionary<string, T> result, ItemReadInterfaceDelegate<T> lambda)
        {
            result ??= new Dictionary<string,T>();
            return ReadDictionary(source, result, lambda);
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadDictionary<T>([NotNull] this _READABLEBLOCK source, IDictionary<string, T> result, ItemReadInterfaceDelegate<T> lambda)        
        {
            result.Clear();

            source = source.ReadPackedU64(out var count);
            if (count == 0) return source;

            for(int i=0; i < (int)count; ++i)
            {                
                source = source.ReadString(out var key);
                source = lambda(source, out var item);
                result[key] = item;
            }            

            return source;
        }

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteListLe<T>([NotNull] this _WRITEABLEBLOCK target, IReadOnlyList<T> items) where T: IConvertible
        {
            items ??= Array.Empty<T>();

            target = target.WriteLeS32(items.Count);
            
            if (items.Count == 0) return target; // this is needed for ArraySegment<T> crashing on null arrays.

            foreach (var item in items)
            {
                target = WriteLeConvertible(target, item);               
            }

            return target;
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadListLe<T>([NotNull] this _READABLEBLOCK source, List<T> list) where T : IConvertible
        {
            source = source.ReadLeS32(out var count);

            list.Clear();

            for (int i = 0; i < count; i++)
            {
                source = ReadLeConvertible<T>(source, out var convertible);
                list.Add(convertible);
            }

            return source;
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadListLe<T>([NotNull] this _READABLEBLOCK source, ref ArraySegment<T> list) where T : IConvertible
        {
            source = source.ReadLeS32(out var count);

            if (list.Array == null || list.Array.Length < count) list = new T[count];
            else list = new ArraySegment<T>(list.Array, 0, count);

            for (int i = 0; i < count; i++)
            {
                source = ReadLeConvertible<T>(source, out var convertible);
                list[i] = convertible;
            }

            return source;
        }

        [return: NotNull]
        public static _READABLEBLOCK ReadListLe<T>([NotNull] this _READABLEBLOCK source, ref T[] list) where T : IConvertible
        {
            source = source.ReadLeS32(out var count);

            Array.Resize(ref list, count);           

            for (int i = 0; i < count; i++)
            {
                source = ReadLeConvertible<T>(source, out var convertible);
                list[i] = convertible;
            }

            return source;
        }

        #endregion

        #region generic

        [return: NotNull]
        public static _READABLEBLOCK ReadLeConvertible<T>([NotNull] this _READABLEBLOCK source, out T convertible) where T : IConvertible
        {
            if (typeof(T) == typeof(Boolean)) { source = source.ReadBool(out var value); convertible = (T)(Object)value; return source; }
            if (typeof(T) == typeof(String)) { source = source.ReadString(out var value); convertible = (T)(Object)value; return source; }

            if (typeof(T) == typeof(Byte)) { source = source.ReadU8(out var value); convertible = (T)(Object)value; return source; }
            if (typeof(T) == typeof(SByte)) { source = source.ReadS8(out var value); convertible = (T)(Object)value; return source; }
            if (typeof(T) == typeof(Int16)) { source = source.ReadLeS16(out var value); convertible = (T)(Object)value; return source; }
            if (typeof(T) == typeof(UInt16)) { source = source.ReadLeU16(out var value); convertible = (T)(Object)value; return source; }
            if (typeof(T) == typeof(Int32)) { source = source.ReadLeS32(out var value); convertible = (T)(Object)value; return source; }
            if (typeof(T) == typeof(UInt32)) { source = source.ReadLeU32(out var value); convertible = (T)(Object)value; return source; }
            if (typeof(T) == typeof(Int64)) { source = source.ReadLeS64(out var value); convertible = (T)(Object)value; return source; }
            if (typeof(T) == typeof(UInt64)) { source = source.ReadLeU64(out var value); convertible = (T)(Object)value; return source; }
            
            if (typeof(T) == typeof(Single)) { source = source.ReadLeF32(out var value); convertible = (T)(Object)value; return source; }
            if (typeof(T) == typeof(Double)) { source = source.ReadLeF64(out var value); convertible = (T)(Object)value; return source; }

            if (typeof(T) == typeof(DateTime)) { source = source.ReadLeDateTime(out var value); convertible = (T)(Object)value; return source; }

            throw new NotSupportedException(typeof(T).Name);
        }

        [return: NotNull]
        public static _WRITEABLEBLOCK WriteLeConvertible<T>([NotNull] this _WRITEABLEBLOCK target, T convertible) where T: IConvertible
        {
            switch (convertible)
            {
                case System.Boolean value: return target.WriteBool(value);
                case System.String value: return target.WriteString(value);

                case System.Byte value: return target.WriteU8(value);
                case System.SByte value: return target.WriteS8(value);
                case System.UInt16 value: return target.WriteLeU16(value);
                case System.Int16 value: return target.WriteLeS16(value);
                case System.UInt32 value: return target.WriteLeU32(value);
                case System.Int32 value: return target.WriteLeS32(value);
                case System.UInt64 value: return target.WriteLeU64(value);
                case System.Int64 value: return target.WriteLeS64(value);
                
                case System.Single value: return target.WriteLeF32(value);
                case System.Double value: return target.WriteLeF64(value);

                case System.DateTime value: return target.WriteLeDateTime(value);

                default: throw new NotSupportedException(typeof(T).Name);
            }
        }      

        #endregion
    
    }
}