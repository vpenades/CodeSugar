// <auto-generated />
// Copyright (c) CodeSugar 2024 Vicente Penades

using System;
using System.Numerics;
using System.Numerics.Tensors;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

#if NET
using System.Runtime.Intrinsics;
#endif

#if NET6_0_OR_GREATER
using VECTOR2FACTORY = System.Runtime.Intrinsics.Vector64;
using VECTOR4FACTORY = System.Runtime.Intrinsics.Vector128;
using VECTOR8FACTORY = System.Runtime.Intrinsics.Vector256;

using VECTOR2 = System.Runtime.Intrinsics.Vector64<float>;
using VECTOR4 = System.Runtime.Intrinsics.Vector128<float>;
using VECTOR8 = System.Runtime.Intrinsics.Vector256<float>;

#endif

#if NET8_0_OR_GREATER
using VECTOR16FACTORY = System.Runtime.Intrinsics.Vector512;

using VECTOR16 = System.Runtime.Intrinsics.Vector512<float>;
#endif

#nullable disable

using MMARSHALL = System.Runtime.InteropServices.MemoryMarshal;
using XYZ = System.Numerics.Vector3;
using XYZW = System.Numerics.Vector4;

#if CODESUGAR_USECODESUGARNAMESPACE
namespace CodeSugar
#elif CODESUGAR_USESYSTEMNAMESPACE
namespace System.Numerics
#else
namespace $rootnamespace$
#endif
{
    partial class CodeSugarForTensors
    {

    #region support structures

    #region RGB

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __RGBx2<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 2 * 3;
        public readonly T _Element0_R;
        public readonly T _Element0_G;
        public readonly T _Element0_B;
        public readonly T _Element1_R;
        public readonly T _Element1_G;
        public readonly T _Element1_B;
        #endregion

        #region API

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __RGBx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)255, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)255).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __RGBx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, 1, src._Element1_R, src._Element1_G, src._Element1_B, 1);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __RGBx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)255, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)255).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __RGBx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, 1, src._Element1_B, src._Element1_G, src._Element1_R, 1);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __RGBx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)255, (int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)255, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __RGBx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(1, src._Element0_R, src._Element0_G, src._Element0_B, 1, src._Element1_R, src._Element1_G, src._Element1_B);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__RGBx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx2<T>,__RGBx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx2<T>,__RGBx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__RGBx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx2<T>,__RGBx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx2<T>,__RGBx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__RGBx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx2<T>,__RGBx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx2<T>,__RGBx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__RGBx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx2<T>,__RGBx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx2<T>,__RGBx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__RGBx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx2<T>,__RGBx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx2<T>,__RGBx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__RGBx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx2<T>,__RGBx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx2<T>,__RGBx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __RGBx4<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 4 * 3;
        public readonly T _Element0_R;
        public readonly T _Element0_G;
        public readonly T _Element0_B;
        public readonly T _Element1_R;
        public readonly T _Element1_G;
        public readonly T _Element1_B;
        public readonly T _Element2_R;
        public readonly T _Element2_G;
        public readonly T _Element2_B;
        public readonly T _Element3_R;
        public readonly T _Element3_G;
        public readonly T _Element3_B;
        #endregion

        #region API

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __RGBx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)255, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)255, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)255, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)255).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __RGBx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, 1, src._Element1_R, src._Element1_G, src._Element1_B, 1, src._Element2_R, src._Element2_G, src._Element2_B, 1, src._Element3_R, src._Element3_G, src._Element3_B, 1);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __RGBx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)255, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)255, (int)src._Element2_B, (int)src._Element2_G, (int)src._Element2_R, (int)255, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)255).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __RGBx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, 1, src._Element1_B, src._Element1_G, src._Element1_R, 1, src._Element2_B, src._Element2_G, src._Element2_R, 1, src._Element3_B, src._Element3_G, src._Element3_R, 1);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __RGBx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)255, (int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)255, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)255, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)255, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __RGBx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(1, src._Element0_R, src._Element0_G, src._Element0_B, 1, src._Element1_R, src._Element1_G, src._Element1_B, 1, src._Element2_R, src._Element2_G, src._Element2_B, 1, src._Element3_R, src._Element3_G, src._Element3_B);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__RGBx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx4<T>,__RGBx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx4<T>,__RGBx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__RGBx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx4<T>,__RGBx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx4<T>,__RGBx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__RGBx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx4<T>,__RGBx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx4<T>,__RGBx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__RGBx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx4<T>,__RGBx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx4<T>,__RGBx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__RGBx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx4<T>,__RGBx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx4<T>,__RGBx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__RGBx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx4<T>,__RGBx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx4<T>,__RGBx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __RGBx8<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 8 * 3;
        public readonly T _Element0_R;
        public readonly T _Element0_G;
        public readonly T _Element0_B;
        public readonly T _Element1_R;
        public readonly T _Element1_G;
        public readonly T _Element1_B;
        public readonly T _Element2_R;
        public readonly T _Element2_G;
        public readonly T _Element2_B;
        public readonly T _Element3_R;
        public readonly T _Element3_G;
        public readonly T _Element3_B;
        public readonly T _Element4_R;
        public readonly T _Element4_G;
        public readonly T _Element4_B;
        public readonly T _Element5_R;
        public readonly T _Element5_G;
        public readonly T _Element5_B;
        public readonly T _Element6_R;
        public readonly T _Element6_G;
        public readonly T _Element6_B;
        public readonly T _Element7_R;
        public readonly T _Element7_G;
        public readonly T _Element7_B;
        #endregion

        #region API

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __RGBx8<byte> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_R, (int)src._Element2_G).ConvertToSingle();
            dstY = VECTOR8FACTORY.Create((int)src._Element2_B, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element4_R, (int)src._Element4_G, (int)src._Element4_B, (int)src._Element5_R).ConvertToSingle();
            dstZ = VECTOR8FACTORY.Create((int)src._Element5_G, (int)src._Element5_B, (int)src._Element6_R, (int)src._Element6_G, (int)src._Element6_B, (int)src._Element7_R, (int)src._Element7_G, (int)src._Element7_B).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __RGBx8<float> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_R, src._Element2_G);
            dstY = VECTOR8FACTORY.Create(src._Element2_B, src._Element3_R, src._Element3_G, src._Element3_B, src._Element4_R, src._Element4_G, src._Element4_B, src._Element5_R);
            dstZ = VECTOR8FACTORY.Create(src._Element5_G, src._Element5_B, src._Element6_R, src._Element6_G, src._Element6_B, src._Element7_R, src._Element7_G, src._Element7_B);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __RGBx8<byte> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element2_B, (int)src._Element2_G).ConvertToSingle();
            dstY = VECTOR8FACTORY.Create((int)src._Element2_R, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element4_B, (int)src._Element4_G, (int)src._Element4_R, (int)src._Element5_B).ConvertToSingle();
            dstZ = VECTOR8FACTORY.Create((int)src._Element5_G, (int)src._Element5_R, (int)src._Element6_B, (int)src._Element6_G, (int)src._Element6_R, (int)src._Element7_B, (int)src._Element7_G, (int)src._Element7_R).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __RGBx8<float> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element1_B, src._Element1_G, src._Element1_R, src._Element2_B, src._Element2_G);
            dstY = VECTOR8FACTORY.Create(src._Element2_R, src._Element3_B, src._Element3_G, src._Element3_R, src._Element4_B, src._Element4_G, src._Element4_R, src._Element5_B);
            dstZ = VECTOR8FACTORY.Create(src._Element5_G, src._Element5_R, src._Element6_B, src._Element6_G, src._Element6_R, src._Element7_B, src._Element7_G, src._Element7_R);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__RGBx8<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx8<T>,__RGBx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx8<T>,__RGBx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__RGBx8<T>> src, Span<VECTOR8> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x256.Repeat(mul);
            var add3 = __Vector3x256.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx8<T>,__RGBx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx8<T>,__RGBx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__RGBx8<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx8<T>,__RGBx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx8<T>,__RGBx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__RGBx8<T>> src, Span<VECTOR8> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x256.Repeat(mul);
            var add3 = __Vector3x256.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx8<T>,__RGBx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx8<T>,__RGBx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __RGBx16<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 16 * 3;
        public readonly T _Element0_R;
        public readonly T _Element0_G;
        public readonly T _Element0_B;
        public readonly T _Element1_R;
        public readonly T _Element1_G;
        public readonly T _Element1_B;
        public readonly T _Element2_R;
        public readonly T _Element2_G;
        public readonly T _Element2_B;
        public readonly T _Element3_R;
        public readonly T _Element3_G;
        public readonly T _Element3_B;
        public readonly T _Element4_R;
        public readonly T _Element4_G;
        public readonly T _Element4_B;
        public readonly T _Element5_R;
        public readonly T _Element5_G;
        public readonly T _Element5_B;
        public readonly T _Element6_R;
        public readonly T _Element6_G;
        public readonly T _Element6_B;
        public readonly T _Element7_R;
        public readonly T _Element7_G;
        public readonly T _Element7_B;
        public readonly T _Element8_R;
        public readonly T _Element8_G;
        public readonly T _Element8_B;
        public readonly T _Element9_R;
        public readonly T _Element9_G;
        public readonly T _Element9_B;
        public readonly T _Element10_R;
        public readonly T _Element10_G;
        public readonly T _Element10_B;
        public readonly T _Element11_R;
        public readonly T _Element11_G;
        public readonly T _Element11_B;
        public readonly T _Element12_R;
        public readonly T _Element12_G;
        public readonly T _Element12_B;
        public readonly T _Element13_R;
        public readonly T _Element13_G;
        public readonly T _Element13_B;
        public readonly T _Element14_R;
        public readonly T _Element14_G;
        public readonly T _Element14_B;
        public readonly T _Element15_R;
        public readonly T _Element15_G;
        public readonly T _Element15_B;
        #endregion

        #region API

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __RGBx16<byte> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element4_R, (int)src._Element4_G, (int)src._Element4_B, (int)src._Element5_R).ConvertToSingle();
            dstY = VECTOR16FACTORY.Create((int)src._Element5_G, (int)src._Element5_B, (int)src._Element6_R, (int)src._Element6_G, (int)src._Element6_B, (int)src._Element7_R, (int)src._Element7_G, (int)src._Element7_B, (int)src._Element8_R, (int)src._Element8_G, (int)src._Element8_B, (int)src._Element9_R, (int)src._Element9_G, (int)src._Element9_B, (int)src._Element10_R, (int)src._Element10_G).ConvertToSingle();
            dstZ = VECTOR16FACTORY.Create((int)src._Element10_B, (int)src._Element11_R, (int)src._Element11_G, (int)src._Element11_B, (int)src._Element12_R, (int)src._Element12_G, (int)src._Element12_B, (int)src._Element13_R, (int)src._Element13_G, (int)src._Element13_B, (int)src._Element14_R, (int)src._Element14_G, (int)src._Element14_B, (int)src._Element15_R, (int)src._Element15_G, (int)src._Element15_B).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __RGBx16<float> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_R, src._Element2_G, src._Element2_B, src._Element3_R, src._Element3_G, src._Element3_B, src._Element4_R, src._Element4_G, src._Element4_B, src._Element5_R);
            dstY = VECTOR16FACTORY.Create(src._Element5_G, src._Element5_B, src._Element6_R, src._Element6_G, src._Element6_B, src._Element7_R, src._Element7_G, src._Element7_B, src._Element8_R, src._Element8_G, src._Element8_B, src._Element9_R, src._Element9_G, src._Element9_B, src._Element10_R, src._Element10_G);
            dstZ = VECTOR16FACTORY.Create(src._Element10_B, src._Element11_R, src._Element11_G, src._Element11_B, src._Element12_R, src._Element12_G, src._Element12_B, src._Element13_R, src._Element13_G, src._Element13_B, src._Element14_R, src._Element14_G, src._Element14_B, src._Element15_R, src._Element15_G, src._Element15_B);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __RGBx16<byte> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element2_B, (int)src._Element2_G, (int)src._Element2_R, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element4_B, (int)src._Element4_G, (int)src._Element4_R, (int)src._Element5_B).ConvertToSingle();
            dstY = VECTOR16FACTORY.Create((int)src._Element5_G, (int)src._Element5_R, (int)src._Element6_B, (int)src._Element6_G, (int)src._Element6_R, (int)src._Element7_B, (int)src._Element7_G, (int)src._Element7_R, (int)src._Element8_B, (int)src._Element8_G, (int)src._Element8_R, (int)src._Element9_B, (int)src._Element9_G, (int)src._Element9_R, (int)src._Element10_B, (int)src._Element10_G).ConvertToSingle();
            dstZ = VECTOR16FACTORY.Create((int)src._Element10_R, (int)src._Element11_B, (int)src._Element11_G, (int)src._Element11_R, (int)src._Element12_B, (int)src._Element12_G, (int)src._Element12_R, (int)src._Element13_B, (int)src._Element13_G, (int)src._Element13_R, (int)src._Element14_B, (int)src._Element14_G, (int)src._Element14_R, (int)src._Element15_B, (int)src._Element15_G, (int)src._Element15_R).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __RGBx16<float> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element1_B, src._Element1_G, src._Element1_R, src._Element2_B, src._Element2_G, src._Element2_R, src._Element3_B, src._Element3_G, src._Element3_R, src._Element4_B, src._Element4_G, src._Element4_R, src._Element5_B);
            dstY = VECTOR16FACTORY.Create(src._Element5_G, src._Element5_R, src._Element6_B, src._Element6_G, src._Element6_R, src._Element7_B, src._Element7_G, src._Element7_R, src._Element8_B, src._Element8_G, src._Element8_R, src._Element9_B, src._Element9_G, src._Element9_R, src._Element10_B, src._Element10_G);
            dstZ = VECTOR16FACTORY.Create(src._Element10_R, src._Element11_B, src._Element11_G, src._Element11_R, src._Element12_B, src._Element12_G, src._Element12_R, src._Element13_B, src._Element13_G, src._Element13_R, src._Element14_B, src._Element14_G, src._Element14_R, src._Element15_B, src._Element15_G, src._Element15_R);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__RGBx16<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx16<T>,__RGBx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx16<T>,__RGBx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__RGBx16<T>> src, Span<VECTOR16> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x512.Repeat(mul);
            var add3 = __Vector3x512.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx16<T>,__RGBx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx16<T>,__RGBx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__RGBx16<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx16<T>,__RGBx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx16<T>,__RGBx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__RGBx16<T>> src, Span<VECTOR16> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x512.Repeat(mul);
            var add3 = __Vector3x512.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx16<T>,__RGBx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBx16<T>,__RGBx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    #endregion

    #region BGR

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __BGRx2<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 2 * 3;
        public readonly T _Element0_B;
        public readonly T _Element0_G;
        public readonly T _Element0_R;
        public readonly T _Element1_B;
        public readonly T _Element1_G;
        public readonly T _Element1_R;
        #endregion

        #region API

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __BGRx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)255, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)255).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __BGRx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, 1, src._Element1_R, src._Element1_G, src._Element1_B, 1);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __BGRx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)255, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)255).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __BGRx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, 1, src._Element1_B, src._Element1_G, src._Element1_R, 1);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __BGRx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)255, (int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)255, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __BGRx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(1, src._Element0_R, src._Element0_G, src._Element0_B, 1, src._Element1_R, src._Element1_G, src._Element1_B);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__BGRx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx2<T>,__BGRx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx2<T>,__BGRx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__BGRx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx2<T>,__BGRx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx2<T>,__BGRx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__BGRx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx2<T>,__BGRx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx2<T>,__BGRx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__BGRx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx2<T>,__BGRx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx2<T>,__BGRx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__BGRx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx2<T>,__BGRx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx2<T>,__BGRx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__BGRx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx2<T>,__BGRx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx2<T>,__BGRx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __BGRx4<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 4 * 3;
        public readonly T _Element0_B;
        public readonly T _Element0_G;
        public readonly T _Element0_R;
        public readonly T _Element1_B;
        public readonly T _Element1_G;
        public readonly T _Element1_R;
        public readonly T _Element2_B;
        public readonly T _Element2_G;
        public readonly T _Element2_R;
        public readonly T _Element3_B;
        public readonly T _Element3_G;
        public readonly T _Element3_R;
        #endregion

        #region API

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __BGRx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)255, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)255, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)255, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)255).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __BGRx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, 1, src._Element1_R, src._Element1_G, src._Element1_B, 1, src._Element2_R, src._Element2_G, src._Element2_B, 1, src._Element3_R, src._Element3_G, src._Element3_B, 1);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __BGRx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)255, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)255, (int)src._Element2_B, (int)src._Element2_G, (int)src._Element2_R, (int)255, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)255).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __BGRx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, 1, src._Element1_B, src._Element1_G, src._Element1_R, 1, src._Element2_B, src._Element2_G, src._Element2_R, 1, src._Element3_B, src._Element3_G, src._Element3_R, 1);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __BGRx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)255, (int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)255, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)255, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)255, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __BGRx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(1, src._Element0_R, src._Element0_G, src._Element0_B, 1, src._Element1_R, src._Element1_G, src._Element1_B, 1, src._Element2_R, src._Element2_G, src._Element2_B, 1, src._Element3_R, src._Element3_G, src._Element3_B);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__BGRx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx4<T>,__BGRx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx4<T>,__BGRx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__BGRx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx4<T>,__BGRx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx4<T>,__BGRx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__BGRx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx4<T>,__BGRx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx4<T>,__BGRx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__BGRx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx4<T>,__BGRx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx4<T>,__BGRx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__BGRx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx4<T>,__BGRx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx4<T>,__BGRx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__BGRx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx4<T>,__BGRx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx4<T>,__BGRx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __BGRx8<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 8 * 3;
        public readonly T _Element0_B;
        public readonly T _Element0_G;
        public readonly T _Element0_R;
        public readonly T _Element1_B;
        public readonly T _Element1_G;
        public readonly T _Element1_R;
        public readonly T _Element2_B;
        public readonly T _Element2_G;
        public readonly T _Element2_R;
        public readonly T _Element3_B;
        public readonly T _Element3_G;
        public readonly T _Element3_R;
        public readonly T _Element4_B;
        public readonly T _Element4_G;
        public readonly T _Element4_R;
        public readonly T _Element5_B;
        public readonly T _Element5_G;
        public readonly T _Element5_R;
        public readonly T _Element6_B;
        public readonly T _Element6_G;
        public readonly T _Element6_R;
        public readonly T _Element7_B;
        public readonly T _Element7_G;
        public readonly T _Element7_R;
        #endregion

        #region API

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __BGRx8<byte> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_R, (int)src._Element2_G).ConvertToSingle();
            dstY = VECTOR8FACTORY.Create((int)src._Element2_B, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element4_R, (int)src._Element4_G, (int)src._Element4_B, (int)src._Element5_R).ConvertToSingle();
            dstZ = VECTOR8FACTORY.Create((int)src._Element5_G, (int)src._Element5_B, (int)src._Element6_R, (int)src._Element6_G, (int)src._Element6_B, (int)src._Element7_R, (int)src._Element7_G, (int)src._Element7_B).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __BGRx8<float> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_R, src._Element2_G);
            dstY = VECTOR8FACTORY.Create(src._Element2_B, src._Element3_R, src._Element3_G, src._Element3_B, src._Element4_R, src._Element4_G, src._Element4_B, src._Element5_R);
            dstZ = VECTOR8FACTORY.Create(src._Element5_G, src._Element5_B, src._Element6_R, src._Element6_G, src._Element6_B, src._Element7_R, src._Element7_G, src._Element7_B);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __BGRx8<byte> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element2_B, (int)src._Element2_G).ConvertToSingle();
            dstY = VECTOR8FACTORY.Create((int)src._Element2_R, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element4_B, (int)src._Element4_G, (int)src._Element4_R, (int)src._Element5_B).ConvertToSingle();
            dstZ = VECTOR8FACTORY.Create((int)src._Element5_G, (int)src._Element5_R, (int)src._Element6_B, (int)src._Element6_G, (int)src._Element6_R, (int)src._Element7_B, (int)src._Element7_G, (int)src._Element7_R).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __BGRx8<float> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element1_B, src._Element1_G, src._Element1_R, src._Element2_B, src._Element2_G);
            dstY = VECTOR8FACTORY.Create(src._Element2_R, src._Element3_B, src._Element3_G, src._Element3_R, src._Element4_B, src._Element4_G, src._Element4_R, src._Element5_B);
            dstZ = VECTOR8FACTORY.Create(src._Element5_G, src._Element5_R, src._Element6_B, src._Element6_G, src._Element6_R, src._Element7_B, src._Element7_G, src._Element7_R);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__BGRx8<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx8<T>,__BGRx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx8<T>,__BGRx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__BGRx8<T>> src, Span<VECTOR8> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x256.Repeat(mul);
            var add3 = __Vector3x256.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx8<T>,__BGRx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx8<T>,__BGRx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__BGRx8<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx8<T>,__BGRx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx8<T>,__BGRx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__BGRx8<T>> src, Span<VECTOR8> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x256.Repeat(mul);
            var add3 = __Vector3x256.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx8<T>,__BGRx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx8<T>,__BGRx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __BGRx16<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 16 * 3;
        public readonly T _Element0_B;
        public readonly T _Element0_G;
        public readonly T _Element0_R;
        public readonly T _Element1_B;
        public readonly T _Element1_G;
        public readonly T _Element1_R;
        public readonly T _Element2_B;
        public readonly T _Element2_G;
        public readonly T _Element2_R;
        public readonly T _Element3_B;
        public readonly T _Element3_G;
        public readonly T _Element3_R;
        public readonly T _Element4_B;
        public readonly T _Element4_G;
        public readonly T _Element4_R;
        public readonly T _Element5_B;
        public readonly T _Element5_G;
        public readonly T _Element5_R;
        public readonly T _Element6_B;
        public readonly T _Element6_G;
        public readonly T _Element6_R;
        public readonly T _Element7_B;
        public readonly T _Element7_G;
        public readonly T _Element7_R;
        public readonly T _Element8_B;
        public readonly T _Element8_G;
        public readonly T _Element8_R;
        public readonly T _Element9_B;
        public readonly T _Element9_G;
        public readonly T _Element9_R;
        public readonly T _Element10_B;
        public readonly T _Element10_G;
        public readonly T _Element10_R;
        public readonly T _Element11_B;
        public readonly T _Element11_G;
        public readonly T _Element11_R;
        public readonly T _Element12_B;
        public readonly T _Element12_G;
        public readonly T _Element12_R;
        public readonly T _Element13_B;
        public readonly T _Element13_G;
        public readonly T _Element13_R;
        public readonly T _Element14_B;
        public readonly T _Element14_G;
        public readonly T _Element14_R;
        public readonly T _Element15_B;
        public readonly T _Element15_G;
        public readonly T _Element15_R;
        #endregion

        #region API

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __BGRx16<byte> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element4_R, (int)src._Element4_G, (int)src._Element4_B, (int)src._Element5_R).ConvertToSingle();
            dstY = VECTOR16FACTORY.Create((int)src._Element5_G, (int)src._Element5_B, (int)src._Element6_R, (int)src._Element6_G, (int)src._Element6_B, (int)src._Element7_R, (int)src._Element7_G, (int)src._Element7_B, (int)src._Element8_R, (int)src._Element8_G, (int)src._Element8_B, (int)src._Element9_R, (int)src._Element9_G, (int)src._Element9_B, (int)src._Element10_R, (int)src._Element10_G).ConvertToSingle();
            dstZ = VECTOR16FACTORY.Create((int)src._Element10_B, (int)src._Element11_R, (int)src._Element11_G, (int)src._Element11_B, (int)src._Element12_R, (int)src._Element12_G, (int)src._Element12_B, (int)src._Element13_R, (int)src._Element13_G, (int)src._Element13_B, (int)src._Element14_R, (int)src._Element14_G, (int)src._Element14_B, (int)src._Element15_R, (int)src._Element15_G, (int)src._Element15_B).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __BGRx16<float> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_R, src._Element2_G, src._Element2_B, src._Element3_R, src._Element3_G, src._Element3_B, src._Element4_R, src._Element4_G, src._Element4_B, src._Element5_R);
            dstY = VECTOR16FACTORY.Create(src._Element5_G, src._Element5_B, src._Element6_R, src._Element6_G, src._Element6_B, src._Element7_R, src._Element7_G, src._Element7_B, src._Element8_R, src._Element8_G, src._Element8_B, src._Element9_R, src._Element9_G, src._Element9_B, src._Element10_R, src._Element10_G);
            dstZ = VECTOR16FACTORY.Create(src._Element10_B, src._Element11_R, src._Element11_G, src._Element11_B, src._Element12_R, src._Element12_G, src._Element12_B, src._Element13_R, src._Element13_G, src._Element13_B, src._Element14_R, src._Element14_G, src._Element14_B, src._Element15_R, src._Element15_G, src._Element15_B);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __BGRx16<byte> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element2_B, (int)src._Element2_G, (int)src._Element2_R, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element4_B, (int)src._Element4_G, (int)src._Element4_R, (int)src._Element5_B).ConvertToSingle();
            dstY = VECTOR16FACTORY.Create((int)src._Element5_G, (int)src._Element5_R, (int)src._Element6_B, (int)src._Element6_G, (int)src._Element6_R, (int)src._Element7_B, (int)src._Element7_G, (int)src._Element7_R, (int)src._Element8_B, (int)src._Element8_G, (int)src._Element8_R, (int)src._Element9_B, (int)src._Element9_G, (int)src._Element9_R, (int)src._Element10_B, (int)src._Element10_G).ConvertToSingle();
            dstZ = VECTOR16FACTORY.Create((int)src._Element10_R, (int)src._Element11_B, (int)src._Element11_G, (int)src._Element11_R, (int)src._Element12_B, (int)src._Element12_G, (int)src._Element12_R, (int)src._Element13_B, (int)src._Element13_G, (int)src._Element13_R, (int)src._Element14_B, (int)src._Element14_G, (int)src._Element14_R, (int)src._Element15_B, (int)src._Element15_G, (int)src._Element15_R).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __BGRx16<float> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element1_B, src._Element1_G, src._Element1_R, src._Element2_B, src._Element2_G, src._Element2_R, src._Element3_B, src._Element3_G, src._Element3_R, src._Element4_B, src._Element4_G, src._Element4_R, src._Element5_B);
            dstY = VECTOR16FACTORY.Create(src._Element5_G, src._Element5_R, src._Element6_B, src._Element6_G, src._Element6_R, src._Element7_B, src._Element7_G, src._Element7_R, src._Element8_B, src._Element8_G, src._Element8_R, src._Element9_B, src._Element9_G, src._Element9_R, src._Element10_B, src._Element10_G);
            dstZ = VECTOR16FACTORY.Create(src._Element10_R, src._Element11_B, src._Element11_G, src._Element11_R, src._Element12_B, src._Element12_G, src._Element12_R, src._Element13_B, src._Element13_G, src._Element13_R, src._Element14_B, src._Element14_G, src._Element14_R, src._Element15_B, src._Element15_G, src._Element15_R);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__BGRx16<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx16<T>,__BGRx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx16<T>,__BGRx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__BGRx16<T>> src, Span<VECTOR16> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x512.Repeat(mul);
            var add3 = __Vector3x512.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx16<T>,__BGRx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx16<T>,__BGRx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__BGRx16<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx16<T>,__BGRx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx16<T>,__BGRx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__BGRx16<T>> src, Span<VECTOR16> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x512.Repeat(mul);
            var add3 = __Vector3x512.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx16<T>,__BGRx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRx16<T>,__BGRx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    #endregion

    #region RGBA

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __RGBAx2<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 2 * 4;
        public readonly T _Element0_R;
        public readonly T _Element0_G;
        public readonly T _Element0_B;
        public readonly T _Element0_A;
        public readonly T _Element1_R;
        public readonly T _Element1_G;
        public readonly T _Element1_B;
        public readonly T _Element1_A;
        #endregion

        #region API

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __RGBAx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element0_A, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element1_A).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __RGBAx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element0_A, src._Element1_R, src._Element1_G, src._Element1_B, src._Element1_A);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __RGBAx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element0_A, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element1_A).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __RGBAx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element0_A, src._Element1_B, src._Element1_G, src._Element1_R, src._Element1_A);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __RGBAx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_A, (int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_A, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __RGBAx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_A, src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_A, src._Element1_R, src._Element1_G, src._Element1_B);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__RGBAx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx2<T>,__RGBAx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx2<T>,__RGBAx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__RGBAx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx2<T>,__RGBAx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx2<T>,__RGBAx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__RGBAx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx2<T>,__RGBAx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx2<T>,__RGBAx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__RGBAx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx2<T>,__RGBAx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx2<T>,__RGBAx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__RGBAx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx2<T>,__RGBAx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx2<T>,__RGBAx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__RGBAx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx2<T>,__RGBAx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx2<T>,__RGBAx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __RGBAx4<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 4 * 4;
        public readonly T _Element0_R;
        public readonly T _Element0_G;
        public readonly T _Element0_B;
        public readonly T _Element0_A;
        public readonly T _Element1_R;
        public readonly T _Element1_G;
        public readonly T _Element1_B;
        public readonly T _Element1_A;
        public readonly T _Element2_R;
        public readonly T _Element2_G;
        public readonly T _Element2_B;
        public readonly T _Element2_A;
        public readonly T _Element3_R;
        public readonly T _Element3_G;
        public readonly T _Element3_B;
        public readonly T _Element3_A;
        #endregion

        #region API

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __RGBAx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element0_A, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element1_A, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)src._Element2_A, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element3_A).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __RGBAx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element0_A, src._Element1_R, src._Element1_G, src._Element1_B, src._Element1_A, src._Element2_R, src._Element2_G, src._Element2_B, src._Element2_A, src._Element3_R, src._Element3_G, src._Element3_B, src._Element3_A);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __RGBAx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element0_A, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element1_A, (int)src._Element2_B, (int)src._Element2_G, (int)src._Element2_R, (int)src._Element2_A, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element3_A).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __RGBAx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element0_A, src._Element1_B, src._Element1_G, src._Element1_R, src._Element1_A, src._Element2_B, src._Element2_G, src._Element2_R, src._Element2_A, src._Element3_B, src._Element3_G, src._Element3_R, src._Element3_A);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __RGBAx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_A, (int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_A, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_A, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)src._Element3_A, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __RGBAx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_A, src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_A, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_A, src._Element2_R, src._Element2_G, src._Element2_B, src._Element3_A, src._Element3_R, src._Element3_G, src._Element3_B);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__RGBAx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx4<T>,__RGBAx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx4<T>,__RGBAx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__RGBAx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx4<T>,__RGBAx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx4<T>,__RGBAx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__RGBAx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx4<T>,__RGBAx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx4<T>,__RGBAx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__RGBAx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx4<T>,__RGBAx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx4<T>,__RGBAx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__RGBAx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx4<T>,__RGBAx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx4<T>,__RGBAx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__RGBAx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx4<T>,__RGBAx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx4<T>,__RGBAx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __RGBAx8<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 8 * 4;
        public readonly T _Element0_R;
        public readonly T _Element0_G;
        public readonly T _Element0_B;
        public readonly T _Element0_A;
        public readonly T _Element1_R;
        public readonly T _Element1_G;
        public readonly T _Element1_B;
        public readonly T _Element1_A;
        public readonly T _Element2_R;
        public readonly T _Element2_G;
        public readonly T _Element2_B;
        public readonly T _Element2_A;
        public readonly T _Element3_R;
        public readonly T _Element3_G;
        public readonly T _Element3_B;
        public readonly T _Element3_A;
        public readonly T _Element4_R;
        public readonly T _Element4_G;
        public readonly T _Element4_B;
        public readonly T _Element4_A;
        public readonly T _Element5_R;
        public readonly T _Element5_G;
        public readonly T _Element5_B;
        public readonly T _Element5_A;
        public readonly T _Element6_R;
        public readonly T _Element6_G;
        public readonly T _Element6_B;
        public readonly T _Element6_A;
        public readonly T _Element7_R;
        public readonly T _Element7_G;
        public readonly T _Element7_B;
        public readonly T _Element7_A;
        #endregion

        #region API

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __RGBAx8<byte> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_R, (int)src._Element2_G).ConvertToSingle();
            dstY = VECTOR8FACTORY.Create((int)src._Element2_B, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element4_R, (int)src._Element4_G, (int)src._Element4_B, (int)src._Element5_R).ConvertToSingle();
            dstZ = VECTOR8FACTORY.Create((int)src._Element5_G, (int)src._Element5_B, (int)src._Element6_R, (int)src._Element6_G, (int)src._Element6_B, (int)src._Element7_R, (int)src._Element7_G, (int)src._Element7_B).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __RGBAx8<float> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_R, src._Element2_G);
            dstY = VECTOR8FACTORY.Create(src._Element2_B, src._Element3_R, src._Element3_G, src._Element3_B, src._Element4_R, src._Element4_G, src._Element4_B, src._Element5_R);
            dstZ = VECTOR8FACTORY.Create(src._Element5_G, src._Element5_B, src._Element6_R, src._Element6_G, src._Element6_B, src._Element7_R, src._Element7_G, src._Element7_B);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __RGBAx8<byte> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element2_B, (int)src._Element2_G).ConvertToSingle();
            dstY = VECTOR8FACTORY.Create((int)src._Element2_R, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element4_B, (int)src._Element4_G, (int)src._Element4_R, (int)src._Element5_B).ConvertToSingle();
            dstZ = VECTOR8FACTORY.Create((int)src._Element5_G, (int)src._Element5_R, (int)src._Element6_B, (int)src._Element6_G, (int)src._Element6_R, (int)src._Element7_B, (int)src._Element7_G, (int)src._Element7_R).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __RGBAx8<float> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element1_B, src._Element1_G, src._Element1_R, src._Element2_B, src._Element2_G);
            dstY = VECTOR8FACTORY.Create(src._Element2_R, src._Element3_B, src._Element3_G, src._Element3_R, src._Element4_B, src._Element4_G, src._Element4_R, src._Element5_B);
            dstZ = VECTOR8FACTORY.Create(src._Element5_G, src._Element5_R, src._Element6_B, src._Element6_G, src._Element6_R, src._Element7_B, src._Element7_G, src._Element7_R);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__RGBAx8<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx8<T>,__RGBAx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx8<T>,__RGBAx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__RGBAx8<T>> src, Span<VECTOR8> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x256.Repeat(mul);
            var add3 = __Vector3x256.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx8<T>,__RGBAx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx8<T>,__RGBAx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__RGBAx8<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx8<T>,__RGBAx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx8<T>,__RGBAx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__RGBAx8<T>> src, Span<VECTOR8> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x256.Repeat(mul);
            var add3 = __Vector3x256.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx8<T>,__RGBAx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx8<T>,__RGBAx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __RGBAx16<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 16 * 4;
        public readonly T _Element0_R;
        public readonly T _Element0_G;
        public readonly T _Element0_B;
        public readonly T _Element0_A;
        public readonly T _Element1_R;
        public readonly T _Element1_G;
        public readonly T _Element1_B;
        public readonly T _Element1_A;
        public readonly T _Element2_R;
        public readonly T _Element2_G;
        public readonly T _Element2_B;
        public readonly T _Element2_A;
        public readonly T _Element3_R;
        public readonly T _Element3_G;
        public readonly T _Element3_B;
        public readonly T _Element3_A;
        public readonly T _Element4_R;
        public readonly T _Element4_G;
        public readonly T _Element4_B;
        public readonly T _Element4_A;
        public readonly T _Element5_R;
        public readonly T _Element5_G;
        public readonly T _Element5_B;
        public readonly T _Element5_A;
        public readonly T _Element6_R;
        public readonly T _Element6_G;
        public readonly T _Element6_B;
        public readonly T _Element6_A;
        public readonly T _Element7_R;
        public readonly T _Element7_G;
        public readonly T _Element7_B;
        public readonly T _Element7_A;
        public readonly T _Element8_R;
        public readonly T _Element8_G;
        public readonly T _Element8_B;
        public readonly T _Element8_A;
        public readonly T _Element9_R;
        public readonly T _Element9_G;
        public readonly T _Element9_B;
        public readonly T _Element9_A;
        public readonly T _Element10_R;
        public readonly T _Element10_G;
        public readonly T _Element10_B;
        public readonly T _Element10_A;
        public readonly T _Element11_R;
        public readonly T _Element11_G;
        public readonly T _Element11_B;
        public readonly T _Element11_A;
        public readonly T _Element12_R;
        public readonly T _Element12_G;
        public readonly T _Element12_B;
        public readonly T _Element12_A;
        public readonly T _Element13_R;
        public readonly T _Element13_G;
        public readonly T _Element13_B;
        public readonly T _Element13_A;
        public readonly T _Element14_R;
        public readonly T _Element14_G;
        public readonly T _Element14_B;
        public readonly T _Element14_A;
        public readonly T _Element15_R;
        public readonly T _Element15_G;
        public readonly T _Element15_B;
        public readonly T _Element15_A;
        #endregion

        #region API

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __RGBAx16<byte> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element4_R, (int)src._Element4_G, (int)src._Element4_B, (int)src._Element5_R).ConvertToSingle();
            dstY = VECTOR16FACTORY.Create((int)src._Element5_G, (int)src._Element5_B, (int)src._Element6_R, (int)src._Element6_G, (int)src._Element6_B, (int)src._Element7_R, (int)src._Element7_G, (int)src._Element7_B, (int)src._Element8_R, (int)src._Element8_G, (int)src._Element8_B, (int)src._Element9_R, (int)src._Element9_G, (int)src._Element9_B, (int)src._Element10_R, (int)src._Element10_G).ConvertToSingle();
            dstZ = VECTOR16FACTORY.Create((int)src._Element10_B, (int)src._Element11_R, (int)src._Element11_G, (int)src._Element11_B, (int)src._Element12_R, (int)src._Element12_G, (int)src._Element12_B, (int)src._Element13_R, (int)src._Element13_G, (int)src._Element13_B, (int)src._Element14_R, (int)src._Element14_G, (int)src._Element14_B, (int)src._Element15_R, (int)src._Element15_G, (int)src._Element15_B).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __RGBAx16<float> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_R, src._Element2_G, src._Element2_B, src._Element3_R, src._Element3_G, src._Element3_B, src._Element4_R, src._Element4_G, src._Element4_B, src._Element5_R);
            dstY = VECTOR16FACTORY.Create(src._Element5_G, src._Element5_B, src._Element6_R, src._Element6_G, src._Element6_B, src._Element7_R, src._Element7_G, src._Element7_B, src._Element8_R, src._Element8_G, src._Element8_B, src._Element9_R, src._Element9_G, src._Element9_B, src._Element10_R, src._Element10_G);
            dstZ = VECTOR16FACTORY.Create(src._Element10_B, src._Element11_R, src._Element11_G, src._Element11_B, src._Element12_R, src._Element12_G, src._Element12_B, src._Element13_R, src._Element13_G, src._Element13_B, src._Element14_R, src._Element14_G, src._Element14_B, src._Element15_R, src._Element15_G, src._Element15_B);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __RGBAx16<byte> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element2_B, (int)src._Element2_G, (int)src._Element2_R, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element4_B, (int)src._Element4_G, (int)src._Element4_R, (int)src._Element5_B).ConvertToSingle();
            dstY = VECTOR16FACTORY.Create((int)src._Element5_G, (int)src._Element5_R, (int)src._Element6_B, (int)src._Element6_G, (int)src._Element6_R, (int)src._Element7_B, (int)src._Element7_G, (int)src._Element7_R, (int)src._Element8_B, (int)src._Element8_G, (int)src._Element8_R, (int)src._Element9_B, (int)src._Element9_G, (int)src._Element9_R, (int)src._Element10_B, (int)src._Element10_G).ConvertToSingle();
            dstZ = VECTOR16FACTORY.Create((int)src._Element10_R, (int)src._Element11_B, (int)src._Element11_G, (int)src._Element11_R, (int)src._Element12_B, (int)src._Element12_G, (int)src._Element12_R, (int)src._Element13_B, (int)src._Element13_G, (int)src._Element13_R, (int)src._Element14_B, (int)src._Element14_G, (int)src._Element14_R, (int)src._Element15_B, (int)src._Element15_G, (int)src._Element15_R).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __RGBAx16<float> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element1_B, src._Element1_G, src._Element1_R, src._Element2_B, src._Element2_G, src._Element2_R, src._Element3_B, src._Element3_G, src._Element3_R, src._Element4_B, src._Element4_G, src._Element4_R, src._Element5_B);
            dstY = VECTOR16FACTORY.Create(src._Element5_G, src._Element5_R, src._Element6_B, src._Element6_G, src._Element6_R, src._Element7_B, src._Element7_G, src._Element7_R, src._Element8_B, src._Element8_G, src._Element8_R, src._Element9_B, src._Element9_G, src._Element9_R, src._Element10_B, src._Element10_G);
            dstZ = VECTOR16FACTORY.Create(src._Element10_R, src._Element11_B, src._Element11_G, src._Element11_R, src._Element12_B, src._Element12_G, src._Element12_R, src._Element13_B, src._Element13_G, src._Element13_R, src._Element14_B, src._Element14_G, src._Element14_R, src._Element15_B, src._Element15_G, src._Element15_R);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__RGBAx16<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx16<T>,__RGBAx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx16<T>,__RGBAx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__RGBAx16<T>> src, Span<VECTOR16> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x512.Repeat(mul);
            var add3 = __Vector3x512.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx16<T>,__RGBAx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx16<T>,__RGBAx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__RGBAx16<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx16<T>,__RGBAx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx16<T>,__RGBAx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__RGBAx16<T>> src, Span<VECTOR16> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x512.Repeat(mul);
            var add3 = __Vector3x512.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx16<T>,__RGBAx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__RGBAx16<T>,__RGBAx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    #endregion

    #region BGRA

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __BGRAx2<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 2 * 4;
        public readonly T _Element0_B;
        public readonly T _Element0_G;
        public readonly T _Element0_R;
        public readonly T _Element0_A;
        public readonly T _Element1_B;
        public readonly T _Element1_G;
        public readonly T _Element1_R;
        public readonly T _Element1_A;
        #endregion

        #region API

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __BGRAx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element0_A, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element1_A).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __BGRAx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element0_A, src._Element1_R, src._Element1_G, src._Element1_B, src._Element1_A);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __BGRAx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element0_A, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element1_A).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __BGRAx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element0_A, src._Element1_B, src._Element1_G, src._Element1_R, src._Element1_A);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __BGRAx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_A, (int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_A, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __BGRAx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_A, src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_A, src._Element1_R, src._Element1_G, src._Element1_B);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__BGRAx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx2<T>,__BGRAx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx2<T>,__BGRAx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__BGRAx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx2<T>,__BGRAx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx2<T>,__BGRAx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__BGRAx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx2<T>,__BGRAx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx2<T>,__BGRAx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__BGRAx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx2<T>,__BGRAx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx2<T>,__BGRAx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__BGRAx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx2<T>,__BGRAx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx2<T>,__BGRAx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__BGRAx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx2<T>,__BGRAx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx2<T>,__BGRAx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __BGRAx4<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 4 * 4;
        public readonly T _Element0_B;
        public readonly T _Element0_G;
        public readonly T _Element0_R;
        public readonly T _Element0_A;
        public readonly T _Element1_B;
        public readonly T _Element1_G;
        public readonly T _Element1_R;
        public readonly T _Element1_A;
        public readonly T _Element2_B;
        public readonly T _Element2_G;
        public readonly T _Element2_R;
        public readonly T _Element2_A;
        public readonly T _Element3_B;
        public readonly T _Element3_G;
        public readonly T _Element3_R;
        public readonly T _Element3_A;
        #endregion

        #region API

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __BGRAx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element0_A, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element1_A, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)src._Element2_A, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element3_A).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __BGRAx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element0_A, src._Element1_R, src._Element1_G, src._Element1_B, src._Element1_A, src._Element2_R, src._Element2_G, src._Element2_B, src._Element2_A, src._Element3_R, src._Element3_G, src._Element3_B, src._Element3_A);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __BGRAx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element0_A, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element1_A, (int)src._Element2_B, (int)src._Element2_G, (int)src._Element2_R, (int)src._Element2_A, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element3_A).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __BGRAx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element0_A, src._Element1_B, src._Element1_G, src._Element1_R, src._Element1_A, src._Element2_B, src._Element2_G, src._Element2_R, src._Element2_A, src._Element3_B, src._Element3_G, src._Element3_R, src._Element3_A);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __BGRAx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_A, (int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_A, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_A, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)src._Element3_A, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __BGRAx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_A, src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_A, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_A, src._Element2_R, src._Element2_G, src._Element2_B, src._Element3_A, src._Element3_R, src._Element3_G, src._Element3_B);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__BGRAx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx4<T>,__BGRAx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx4<T>,__BGRAx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__BGRAx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx4<T>,__BGRAx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx4<T>,__BGRAx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__BGRAx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx4<T>,__BGRAx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx4<T>,__BGRAx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__BGRAx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx4<T>,__BGRAx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx4<T>,__BGRAx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__BGRAx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx4<T>,__BGRAx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx4<T>,__BGRAx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__BGRAx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx4<T>,__BGRAx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx4<T>,__BGRAx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __BGRAx8<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 8 * 4;
        public readonly T _Element0_B;
        public readonly T _Element0_G;
        public readonly T _Element0_R;
        public readonly T _Element0_A;
        public readonly T _Element1_B;
        public readonly T _Element1_G;
        public readonly T _Element1_R;
        public readonly T _Element1_A;
        public readonly T _Element2_B;
        public readonly T _Element2_G;
        public readonly T _Element2_R;
        public readonly T _Element2_A;
        public readonly T _Element3_B;
        public readonly T _Element3_G;
        public readonly T _Element3_R;
        public readonly T _Element3_A;
        public readonly T _Element4_B;
        public readonly T _Element4_G;
        public readonly T _Element4_R;
        public readonly T _Element4_A;
        public readonly T _Element5_B;
        public readonly T _Element5_G;
        public readonly T _Element5_R;
        public readonly T _Element5_A;
        public readonly T _Element6_B;
        public readonly T _Element6_G;
        public readonly T _Element6_R;
        public readonly T _Element6_A;
        public readonly T _Element7_B;
        public readonly T _Element7_G;
        public readonly T _Element7_R;
        public readonly T _Element7_A;
        #endregion

        #region API

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __BGRAx8<byte> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_R, (int)src._Element2_G).ConvertToSingle();
            dstY = VECTOR8FACTORY.Create((int)src._Element2_B, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element4_R, (int)src._Element4_G, (int)src._Element4_B, (int)src._Element5_R).ConvertToSingle();
            dstZ = VECTOR8FACTORY.Create((int)src._Element5_G, (int)src._Element5_B, (int)src._Element6_R, (int)src._Element6_G, (int)src._Element6_B, (int)src._Element7_R, (int)src._Element7_G, (int)src._Element7_B).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __BGRAx8<float> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_R, src._Element2_G);
            dstY = VECTOR8FACTORY.Create(src._Element2_B, src._Element3_R, src._Element3_G, src._Element3_B, src._Element4_R, src._Element4_G, src._Element4_B, src._Element5_R);
            dstZ = VECTOR8FACTORY.Create(src._Element5_G, src._Element5_B, src._Element6_R, src._Element6_G, src._Element6_B, src._Element7_R, src._Element7_G, src._Element7_B);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __BGRAx8<byte> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element2_B, (int)src._Element2_G).ConvertToSingle();
            dstY = VECTOR8FACTORY.Create((int)src._Element2_R, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element4_B, (int)src._Element4_G, (int)src._Element4_R, (int)src._Element5_B).ConvertToSingle();
            dstZ = VECTOR8FACTORY.Create((int)src._Element5_G, (int)src._Element5_R, (int)src._Element6_B, (int)src._Element6_G, (int)src._Element6_R, (int)src._Element7_B, (int)src._Element7_G, (int)src._Element7_R).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __BGRAx8<float> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element1_B, src._Element1_G, src._Element1_R, src._Element2_B, src._Element2_G);
            dstY = VECTOR8FACTORY.Create(src._Element2_R, src._Element3_B, src._Element3_G, src._Element3_R, src._Element4_B, src._Element4_G, src._Element4_R, src._Element5_B);
            dstZ = VECTOR8FACTORY.Create(src._Element5_G, src._Element5_R, src._Element6_B, src._Element6_G, src._Element6_R, src._Element7_B, src._Element7_G, src._Element7_R);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__BGRAx8<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx8<T>,__BGRAx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx8<T>,__BGRAx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__BGRAx8<T>> src, Span<VECTOR8> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x256.Repeat(mul);
            var add3 = __Vector3x256.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx8<T>,__BGRAx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx8<T>,__BGRAx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__BGRAx8<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx8<T>,__BGRAx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx8<T>,__BGRAx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__BGRAx8<T>> src, Span<VECTOR8> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x256.Repeat(mul);
            var add3 = __Vector3x256.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx8<T>,__BGRAx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx8<T>,__BGRAx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __BGRAx16<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 16 * 4;
        public readonly T _Element0_B;
        public readonly T _Element0_G;
        public readonly T _Element0_R;
        public readonly T _Element0_A;
        public readonly T _Element1_B;
        public readonly T _Element1_G;
        public readonly T _Element1_R;
        public readonly T _Element1_A;
        public readonly T _Element2_B;
        public readonly T _Element2_G;
        public readonly T _Element2_R;
        public readonly T _Element2_A;
        public readonly T _Element3_B;
        public readonly T _Element3_G;
        public readonly T _Element3_R;
        public readonly T _Element3_A;
        public readonly T _Element4_B;
        public readonly T _Element4_G;
        public readonly T _Element4_R;
        public readonly T _Element4_A;
        public readonly T _Element5_B;
        public readonly T _Element5_G;
        public readonly T _Element5_R;
        public readonly T _Element5_A;
        public readonly T _Element6_B;
        public readonly T _Element6_G;
        public readonly T _Element6_R;
        public readonly T _Element6_A;
        public readonly T _Element7_B;
        public readonly T _Element7_G;
        public readonly T _Element7_R;
        public readonly T _Element7_A;
        public readonly T _Element8_B;
        public readonly T _Element8_G;
        public readonly T _Element8_R;
        public readonly T _Element8_A;
        public readonly T _Element9_B;
        public readonly T _Element9_G;
        public readonly T _Element9_R;
        public readonly T _Element9_A;
        public readonly T _Element10_B;
        public readonly T _Element10_G;
        public readonly T _Element10_R;
        public readonly T _Element10_A;
        public readonly T _Element11_B;
        public readonly T _Element11_G;
        public readonly T _Element11_R;
        public readonly T _Element11_A;
        public readonly T _Element12_B;
        public readonly T _Element12_G;
        public readonly T _Element12_R;
        public readonly T _Element12_A;
        public readonly T _Element13_B;
        public readonly T _Element13_G;
        public readonly T _Element13_R;
        public readonly T _Element13_A;
        public readonly T _Element14_B;
        public readonly T _Element14_G;
        public readonly T _Element14_R;
        public readonly T _Element14_A;
        public readonly T _Element15_B;
        public readonly T _Element15_G;
        public readonly T _Element15_R;
        public readonly T _Element15_A;
        #endregion

        #region API

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __BGRAx16<byte> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element4_R, (int)src._Element4_G, (int)src._Element4_B, (int)src._Element5_R).ConvertToSingle();
            dstY = VECTOR16FACTORY.Create((int)src._Element5_G, (int)src._Element5_B, (int)src._Element6_R, (int)src._Element6_G, (int)src._Element6_B, (int)src._Element7_R, (int)src._Element7_G, (int)src._Element7_B, (int)src._Element8_R, (int)src._Element8_G, (int)src._Element8_B, (int)src._Element9_R, (int)src._Element9_G, (int)src._Element9_B, (int)src._Element10_R, (int)src._Element10_G).ConvertToSingle();
            dstZ = VECTOR16FACTORY.Create((int)src._Element10_B, (int)src._Element11_R, (int)src._Element11_G, (int)src._Element11_B, (int)src._Element12_R, (int)src._Element12_G, (int)src._Element12_B, (int)src._Element13_R, (int)src._Element13_G, (int)src._Element13_B, (int)src._Element14_R, (int)src._Element14_G, (int)src._Element14_B, (int)src._Element15_R, (int)src._Element15_G, (int)src._Element15_B).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __BGRAx16<float> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_R, src._Element2_G, src._Element2_B, src._Element3_R, src._Element3_G, src._Element3_B, src._Element4_R, src._Element4_G, src._Element4_B, src._Element5_R);
            dstY = VECTOR16FACTORY.Create(src._Element5_G, src._Element5_B, src._Element6_R, src._Element6_G, src._Element6_B, src._Element7_R, src._Element7_G, src._Element7_B, src._Element8_R, src._Element8_G, src._Element8_B, src._Element9_R, src._Element9_G, src._Element9_B, src._Element10_R, src._Element10_G);
            dstZ = VECTOR16FACTORY.Create(src._Element10_B, src._Element11_R, src._Element11_G, src._Element11_B, src._Element12_R, src._Element12_G, src._Element12_B, src._Element13_R, src._Element13_G, src._Element13_B, src._Element14_R, src._Element14_G, src._Element14_B, src._Element15_R, src._Element15_G, src._Element15_B);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __BGRAx16<byte> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element2_B, (int)src._Element2_G, (int)src._Element2_R, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element4_B, (int)src._Element4_G, (int)src._Element4_R, (int)src._Element5_B).ConvertToSingle();
            dstY = VECTOR16FACTORY.Create((int)src._Element5_G, (int)src._Element5_R, (int)src._Element6_B, (int)src._Element6_G, (int)src._Element6_R, (int)src._Element7_B, (int)src._Element7_G, (int)src._Element7_R, (int)src._Element8_B, (int)src._Element8_G, (int)src._Element8_R, (int)src._Element9_B, (int)src._Element9_G, (int)src._Element9_R, (int)src._Element10_B, (int)src._Element10_G).ConvertToSingle();
            dstZ = VECTOR16FACTORY.Create((int)src._Element10_R, (int)src._Element11_B, (int)src._Element11_G, (int)src._Element11_R, (int)src._Element12_B, (int)src._Element12_G, (int)src._Element12_R, (int)src._Element13_B, (int)src._Element13_G, (int)src._Element13_R, (int)src._Element14_B, (int)src._Element14_G, (int)src._Element14_R, (int)src._Element15_B, (int)src._Element15_G, (int)src._Element15_R).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __BGRAx16<float> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element1_B, src._Element1_G, src._Element1_R, src._Element2_B, src._Element2_G, src._Element2_R, src._Element3_B, src._Element3_G, src._Element3_R, src._Element4_B, src._Element4_G, src._Element4_R, src._Element5_B);
            dstY = VECTOR16FACTORY.Create(src._Element5_G, src._Element5_R, src._Element6_B, src._Element6_G, src._Element6_R, src._Element7_B, src._Element7_G, src._Element7_R, src._Element8_B, src._Element8_G, src._Element8_R, src._Element9_B, src._Element9_G, src._Element9_R, src._Element10_B, src._Element10_G);
            dstZ = VECTOR16FACTORY.Create(src._Element10_R, src._Element11_B, src._Element11_G, src._Element11_R, src._Element12_B, src._Element12_G, src._Element12_R, src._Element13_B, src._Element13_G, src._Element13_R, src._Element14_B, src._Element14_G, src._Element14_R, src._Element15_B, src._Element15_G, src._Element15_R);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__BGRAx16<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx16<T>,__BGRAx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx16<T>,__BGRAx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__BGRAx16<T>> src, Span<VECTOR16> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x512.Repeat(mul);
            var add3 = __Vector3x512.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx16<T>,__BGRAx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx16<T>,__BGRAx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__BGRAx16<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx16<T>,__BGRAx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx16<T>,__BGRAx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__BGRAx16<T>> src, Span<VECTOR16> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x512.Repeat(mul);
            var add3 = __Vector3x512.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx16<T>,__BGRAx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__BGRAx16<T>,__BGRAx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    #endregion

    #region ARGB

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __ARGBx2<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 2 * 4;
        public readonly T _Element0_A;
        public readonly T _Element0_R;
        public readonly T _Element0_G;
        public readonly T _Element0_B;
        public readonly T _Element1_A;
        public readonly T _Element1_R;
        public readonly T _Element1_G;
        public readonly T _Element1_B;
        #endregion

        #region API

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __ARGBx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element0_A, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element1_A).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __ARGBx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element0_A, src._Element1_R, src._Element1_G, src._Element1_B, src._Element1_A);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __ARGBx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element0_A, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element1_A).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __ARGBx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element0_A, src._Element1_B, src._Element1_G, src._Element1_R, src._Element1_A);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __ARGBx2<byte> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create((int)src._Element0_A, (int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_A, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __ARGBx2<float> src, out VECTOR8 dst)
        {
            dst = VECTOR8FACTORY.Create(src._Element0_A, src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_A, src._Element1_R, src._Element1_G, src._Element1_B);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__ARGBx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx2<T>,__ARGBx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx2<T>,__ARGBx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__ARGBx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx2<T>,__ARGBx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx2<T>,__ARGBx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__ARGBx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx2<T>,__ARGBx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx2<T>,__ARGBx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__ARGBx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx2<T>,__ARGBx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx2<T>,__ARGBx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__ARGBx2<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx2<T>,__ARGBx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx2<T>,__ARGBx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__ARGBx2<T>> src, Span<VECTOR8> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector256();
            var add1 = add.RepeatVector256();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx2<T>,__ARGBx2<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx2<T>,__ARGBx2<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __ARGBx4<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 4 * 4;
        public readonly T _Element0_A;
        public readonly T _Element0_R;
        public readonly T _Element0_G;
        public readonly T _Element0_B;
        public readonly T _Element1_A;
        public readonly T _Element1_R;
        public readonly T _Element1_G;
        public readonly T _Element1_B;
        public readonly T _Element2_A;
        public readonly T _Element2_R;
        public readonly T _Element2_G;
        public readonly T _Element2_B;
        public readonly T _Element3_A;
        public readonly T _Element3_R;
        public readonly T _Element3_G;
        public readonly T _Element3_B;
        #endregion

        #region API

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __ARGBx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element0_A, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element1_A, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)src._Element2_A, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element3_A).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGBA(in __ARGBx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element0_A, src._Element1_R, src._Element1_G, src._Element1_B, src._Element1_A, src._Element2_R, src._Element2_G, src._Element2_B, src._Element2_A, src._Element3_R, src._Element3_G, src._Element3_B, src._Element3_A);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __ARGBx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element0_A, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element1_A, (int)src._Element2_B, (int)src._Element2_G, (int)src._Element2_R, (int)src._Element2_A, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element3_A).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGRA(in __ARGBx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element0_A, src._Element1_B, src._Element1_G, src._Element1_R, src._Element1_A, src._Element2_B, src._Element2_G, src._Element2_R, src._Element2_A, src._Element3_B, src._Element3_G, src._Element3_R, src._Element3_A);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __ARGBx4<byte> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create((int)src._Element0_A, (int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_A, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_A, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)src._Element3_A, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToARGB(in __ARGBx4<float> src, out VECTOR16 dst)
        {
            dst = VECTOR16FACTORY.Create(src._Element0_A, src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_A, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_A, src._Element2_R, src._Element2_G, src._Element2_B, src._Element3_A, src._Element3_R, src._Element3_G, src._Element3_B);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__ARGBx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx4<T>,__ARGBx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx4<T>,__ARGBx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGBA(ReadOnlySpan<__ARGBx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx4<T>,__ARGBx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx4<T>,__ARGBx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGBA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__ARGBx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx4<T>,__ARGBx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx4<T>,__ARGBx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGRA(ReadOnlySpan<__ARGBx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx4<T>,__ARGBx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx4<T>,__ARGBx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGRA(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__ARGBx4<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx4<T>,__ARGBx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx4<T>,__ARGBx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToARGB(ReadOnlySpan<__ARGBx4<T>> src, Span<VECTOR16> dst , in XYZW mul, in XYZW add)
        {

            var mul1 = mul.RepeatVector512();
            var add1 = add.RepeatVector512();

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx4<T>,__ARGBx4<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx4<T>,__ARGBx4<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToARGB(item, out dst[0]);
                    dst[0] = dst[0] * mul1 + add1;
                    dst = dst.Slice(1);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __ARGBx8<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 8 * 4;
        public readonly T _Element0_A;
        public readonly T _Element0_R;
        public readonly T _Element0_G;
        public readonly T _Element0_B;
        public readonly T _Element1_A;
        public readonly T _Element1_R;
        public readonly T _Element1_G;
        public readonly T _Element1_B;
        public readonly T _Element2_A;
        public readonly T _Element2_R;
        public readonly T _Element2_G;
        public readonly T _Element2_B;
        public readonly T _Element3_A;
        public readonly T _Element3_R;
        public readonly T _Element3_G;
        public readonly T _Element3_B;
        public readonly T _Element4_A;
        public readonly T _Element4_R;
        public readonly T _Element4_G;
        public readonly T _Element4_B;
        public readonly T _Element5_A;
        public readonly T _Element5_R;
        public readonly T _Element5_G;
        public readonly T _Element5_B;
        public readonly T _Element6_A;
        public readonly T _Element6_R;
        public readonly T _Element6_G;
        public readonly T _Element6_B;
        public readonly T _Element7_A;
        public readonly T _Element7_R;
        public readonly T _Element7_G;
        public readonly T _Element7_B;
        #endregion

        #region API

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __ARGBx8<byte> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_R, (int)src._Element2_G).ConvertToSingle();
            dstY = VECTOR8FACTORY.Create((int)src._Element2_B, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element4_R, (int)src._Element4_G, (int)src._Element4_B, (int)src._Element5_R).ConvertToSingle();
            dstZ = VECTOR8FACTORY.Create((int)src._Element5_G, (int)src._Element5_B, (int)src._Element6_R, (int)src._Element6_G, (int)src._Element6_B, (int)src._Element7_R, (int)src._Element7_G, (int)src._Element7_B).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __ARGBx8<float> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_R, src._Element2_G);
            dstY = VECTOR8FACTORY.Create(src._Element2_B, src._Element3_R, src._Element3_G, src._Element3_B, src._Element4_R, src._Element4_G, src._Element4_B, src._Element5_R);
            dstZ = VECTOR8FACTORY.Create(src._Element5_G, src._Element5_B, src._Element6_R, src._Element6_G, src._Element6_B, src._Element7_R, src._Element7_G, src._Element7_B);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __ARGBx8<byte> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element2_B, (int)src._Element2_G).ConvertToSingle();
            dstY = VECTOR8FACTORY.Create((int)src._Element2_R, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element4_B, (int)src._Element4_G, (int)src._Element4_R, (int)src._Element5_B).ConvertToSingle();
            dstZ = VECTOR8FACTORY.Create((int)src._Element5_G, (int)src._Element5_R, (int)src._Element6_B, (int)src._Element6_G, (int)src._Element6_R, (int)src._Element7_B, (int)src._Element7_G, (int)src._Element7_R).ConvertToSingle();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __ARGBx8<float> src, out VECTOR8 dstX, out VECTOR8 dstY, out VECTOR8 dstZ)
        {
            dstX = VECTOR8FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element1_B, src._Element1_G, src._Element1_R, src._Element2_B, src._Element2_G);
            dstY = VECTOR8FACTORY.Create(src._Element2_R, src._Element3_B, src._Element3_G, src._Element3_R, src._Element4_B, src._Element4_G, src._Element4_R, src._Element5_B);
            dstZ = VECTOR8FACTORY.Create(src._Element5_G, src._Element5_R, src._Element6_B, src._Element6_G, src._Element6_R, src._Element7_B, src._Element7_G, src._Element7_R);
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__ARGBx8<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx8<T>,__ARGBx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx8<T>,__ARGBx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__ARGBx8<T>> src, Span<VECTOR8> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x256.Repeat(mul);
            var add3 = __Vector3x256.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx8<T>,__ARGBx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx8<T>,__ARGBx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET6_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__ARGBx8<T>> src, Span<VECTOR8> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx8<T>,__ARGBx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx8<T>,__ARGBx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__ARGBx8<T>> src, Span<VECTOR8> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x256.Repeat(mul);
            var add3 = __Vector3x256.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx8<T>,__ARGBx8<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx8<T>,__ARGBx8<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    [System.Runtime.InteropServices.StructLayout(LayoutKind.Sequential, Pack = 1)]
    readonly struct __ARGBx16<T> where T: unmanaged, IConvertible
    {
        #region data
        public const int TotalElements = 16 * 4;
        public readonly T _Element0_A;
        public readonly T _Element0_R;
        public readonly T _Element0_G;
        public readonly T _Element0_B;
        public readonly T _Element1_A;
        public readonly T _Element1_R;
        public readonly T _Element1_G;
        public readonly T _Element1_B;
        public readonly T _Element2_A;
        public readonly T _Element2_R;
        public readonly T _Element2_G;
        public readonly T _Element2_B;
        public readonly T _Element3_A;
        public readonly T _Element3_R;
        public readonly T _Element3_G;
        public readonly T _Element3_B;
        public readonly T _Element4_A;
        public readonly T _Element4_R;
        public readonly T _Element4_G;
        public readonly T _Element4_B;
        public readonly T _Element5_A;
        public readonly T _Element5_R;
        public readonly T _Element5_G;
        public readonly T _Element5_B;
        public readonly T _Element6_A;
        public readonly T _Element6_R;
        public readonly T _Element6_G;
        public readonly T _Element6_B;
        public readonly T _Element7_A;
        public readonly T _Element7_R;
        public readonly T _Element7_G;
        public readonly T _Element7_B;
        public readonly T _Element8_A;
        public readonly T _Element8_R;
        public readonly T _Element8_G;
        public readonly T _Element8_B;
        public readonly T _Element9_A;
        public readonly T _Element9_R;
        public readonly T _Element9_G;
        public readonly T _Element9_B;
        public readonly T _Element10_A;
        public readonly T _Element10_R;
        public readonly T _Element10_G;
        public readonly T _Element10_B;
        public readonly T _Element11_A;
        public readonly T _Element11_R;
        public readonly T _Element11_G;
        public readonly T _Element11_B;
        public readonly T _Element12_A;
        public readonly T _Element12_R;
        public readonly T _Element12_G;
        public readonly T _Element12_B;
        public readonly T _Element13_A;
        public readonly T _Element13_R;
        public readonly T _Element13_G;
        public readonly T _Element13_B;
        public readonly T _Element14_A;
        public readonly T _Element14_R;
        public readonly T _Element14_G;
        public readonly T _Element14_B;
        public readonly T _Element15_A;
        public readonly T _Element15_R;
        public readonly T _Element15_G;
        public readonly T _Element15_B;
        #endregion

        #region API

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __ARGBx16<byte> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create((int)src._Element0_R, (int)src._Element0_G, (int)src._Element0_B, (int)src._Element1_R, (int)src._Element1_G, (int)src._Element1_B, (int)src._Element2_R, (int)src._Element2_G, (int)src._Element2_B, (int)src._Element3_R, (int)src._Element3_G, (int)src._Element3_B, (int)src._Element4_R, (int)src._Element4_G, (int)src._Element4_B, (int)src._Element5_R).ConvertToSingle();
            dstY = VECTOR16FACTORY.Create((int)src._Element5_G, (int)src._Element5_B, (int)src._Element6_R, (int)src._Element6_G, (int)src._Element6_B, (int)src._Element7_R, (int)src._Element7_G, (int)src._Element7_B, (int)src._Element8_R, (int)src._Element8_G, (int)src._Element8_B, (int)src._Element9_R, (int)src._Element9_G, (int)src._Element9_B, (int)src._Element10_R, (int)src._Element10_G).ConvertToSingle();
            dstZ = VECTOR16FACTORY.Create((int)src._Element10_B, (int)src._Element11_R, (int)src._Element11_G, (int)src._Element11_B, (int)src._Element12_R, (int)src._Element12_G, (int)src._Element12_B, (int)src._Element13_R, (int)src._Element13_G, (int)src._Element13_B, (int)src._Element14_R, (int)src._Element14_G, (int)src._Element14_B, (int)src._Element15_R, (int)src._Element15_G, (int)src._Element15_B).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToRGB(in __ARGBx16<float> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create(src._Element0_R, src._Element0_G, src._Element0_B, src._Element1_R, src._Element1_G, src._Element1_B, src._Element2_R, src._Element2_G, src._Element2_B, src._Element3_R, src._Element3_G, src._Element3_B, src._Element4_R, src._Element4_G, src._Element4_B, src._Element5_R);
            dstY = VECTOR16FACTORY.Create(src._Element5_G, src._Element5_B, src._Element6_R, src._Element6_G, src._Element6_B, src._Element7_R, src._Element7_G, src._Element7_B, src._Element8_R, src._Element8_G, src._Element8_B, src._Element9_R, src._Element9_G, src._Element9_B, src._Element10_R, src._Element10_G);
            dstZ = VECTOR16FACTORY.Create(src._Element10_B, src._Element11_R, src._Element11_G, src._Element11_B, src._Element12_R, src._Element12_G, src._Element12_B, src._Element13_R, src._Element13_G, src._Element13_B, src._Element14_R, src._Element14_G, src._Element14_B, src._Element15_R, src._Element15_G, src._Element15_B);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __ARGBx16<byte> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create((int)src._Element0_B, (int)src._Element0_G, (int)src._Element0_R, (int)src._Element1_B, (int)src._Element1_G, (int)src._Element1_R, (int)src._Element2_B, (int)src._Element2_G, (int)src._Element2_R, (int)src._Element3_B, (int)src._Element3_G, (int)src._Element3_R, (int)src._Element4_B, (int)src._Element4_G, (int)src._Element4_R, (int)src._Element5_B).ConvertToSingle();
            dstY = VECTOR16FACTORY.Create((int)src._Element5_G, (int)src._Element5_R, (int)src._Element6_B, (int)src._Element6_G, (int)src._Element6_R, (int)src._Element7_B, (int)src._Element7_G, (int)src._Element7_R, (int)src._Element8_B, (int)src._Element8_G, (int)src._Element8_R, (int)src._Element9_B, (int)src._Element9_G, (int)src._Element9_R, (int)src._Element10_B, (int)src._Element10_G).ConvertToSingle();
            dstZ = VECTOR16FACTORY.Create((int)src._Element10_R, (int)src._Element11_B, (int)src._Element11_G, (int)src._Element11_R, (int)src._Element12_B, (int)src._Element12_G, (int)src._Element12_R, (int)src._Element13_B, (int)src._Element13_G, (int)src._Element13_R, (int)src._Element14_B, (int)src._Element14_G, (int)src._Element14_R, (int)src._Element15_B, (int)src._Element15_G, (int)src._Element15_R).ConvertToSingle();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        private static void _ConvertToBGR(in __ARGBx16<float> src, out VECTOR16 dstX, out VECTOR16 dstY, out VECTOR16 dstZ)
        {
            dstX = VECTOR16FACTORY.Create(src._Element0_B, src._Element0_G, src._Element0_R, src._Element1_B, src._Element1_G, src._Element1_R, src._Element2_B, src._Element2_G, src._Element2_R, src._Element3_B, src._Element3_G, src._Element3_R, src._Element4_B, src._Element4_G, src._Element4_R, src._Element5_B);
            dstY = VECTOR16FACTORY.Create(src._Element5_G, src._Element5_R, src._Element6_B, src._Element6_G, src._Element6_R, src._Element7_B, src._Element7_G, src._Element7_R, src._Element8_B, src._Element8_G, src._Element8_R, src._Element9_B, src._Element9_G, src._Element9_R, src._Element10_B, src._Element10_G);
            dstZ = VECTOR16FACTORY.Create(src._Element10_R, src._Element11_B, src._Element11_G, src._Element11_R, src._Element12_B, src._Element12_G, src._Element12_R, src._Element13_B, src._Element13_G, src._Element13_R, src._Element14_B, src._Element14_G, src._Element14_R, src._Element15_B, src._Element15_G, src._Element15_R);
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__ARGBx16<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx16<T>,__ARGBx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx16<T>,__ARGBx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToRGB(ReadOnlySpan<__ARGBx16<T>> src, Span<VECTOR16> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x512.Repeat(mul);
            var add3 = __Vector3x512.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx16<T>,__ARGBx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx16<T>,__ARGBx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToRGB(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__ARGBx16<T>> src, Span<VECTOR16> dst )
        {

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx16<T>,__ARGBx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx16<T>,__ARGBx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif

        #if NET8_0_OR_GREATER
        [MethodImpl(AGRESSIVE)]
        public static void CopyToBGR(ReadOnlySpan<__ARGBx16<T>> src, Span<VECTOR16> dst , in XYZ mul, in XYZ add)
        {

            var mul3 = __Vector3x512.Repeat(mul);
            var add3 = __Vector3x512.Repeat(add);

            if (typeof(Byte) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx16<T>,__ARGBx16<Byte>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            if (typeof(float) == typeof(T))
            {
                var srcTyped = MMARSHALL.Cast<__ARGBx16<T>,__ARGBx16<float>>(src);
                for (int i = 0; i < srcTyped.Length; i++)
                {
                    ref readonly var item = ref srcTyped[i];
                    _ConvertToBGR(item, out dst[0], out dst[1], out dst[2]);
                    dst[0] = dst[0] * mul3.X + add3.X;
                    dst[1] = dst[1] * mul3.Y + add3.Y;
                    dst[2] = dst[2] * mul3.Z + add3.Z;
                    dst = dst.Slice(3);
                }
                return;
            }
            throw new NotImplementedException();
        }
        #endif
        #endregion
    }

    #endregion

    #endregion

    #region public methods

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoRGB(this ReadOnlySpan<byte> src, Span<XYZ> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBx16<byte>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBx8<byte>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoRGB(this ReadOnlySpan<byte> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBx16<byte>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBx8<byte>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoRGB(this ReadOnlySpan<float> src, Span<XYZ> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBx16<float>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBx8<float>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoRGB(this ReadOnlySpan<float> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBx16<float>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBx8<float>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoBGR(this ReadOnlySpan<byte> src, Span<XYZ> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBx16<byte>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBx8<byte>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoBGR(this ReadOnlySpan<byte> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBx16<byte>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBx8<byte>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoBGR(this ReadOnlySpan<float> src, Span<XYZ> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBx16<float>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBx8<float>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoBGR(this ReadOnlySpan<float> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBx16<float>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBx8<float>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoRGBA(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBx4<byte>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBx2<byte>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = 255;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoRGBA(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBx4<byte>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBx2<byte>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = 255;
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoRGBA(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBx4<float>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBx2<float>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = 1;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoRGBA(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBx4<float>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBx2<float>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = 1;
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoBGRA(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBx4<byte>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBx2<byte>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = 255;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoBGRA(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBx4<byte>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBx2<byte>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = 255;
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoBGRA(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBx4<float>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBx2<float>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = 1;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoBGRA(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBx4<float>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBx2<float>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = 1;
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoARGB(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBx4<byte>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBx2<byte>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = 255;
                curr.Y = (float)src[0];
                curr.Z = (float)src[1];
                curr.W = (float)src[2];
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoARGB(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBx4<byte>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBx2<byte>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = 255;
                curr.Y = (float)src[0];
                curr.Z = (float)src[1];
                curr.W = (float)src[2];
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoARGB(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBx4<float>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBx2<float>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = 1;
                curr.Y = (float)src[0];
                curr.Z = (float)src[1];
                curr.W = (float)src[2];
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBtoARGB(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBx4<float>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBx2<float>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = 1;
                curr.Y = (float)src[0];
                curr.Z = (float)src[1];
                curr.W = (float)src[2];
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoRGB(this ReadOnlySpan<byte> src, Span<XYZ> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRx16<byte>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRx8<byte>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoRGB(this ReadOnlySpan<byte> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRx16<byte>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRx8<byte>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoRGB(this ReadOnlySpan<float> src, Span<XYZ> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRx16<float>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRx8<float>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoRGB(this ReadOnlySpan<float> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRx16<float>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRx8<float>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoBGR(this ReadOnlySpan<byte> src, Span<XYZ> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRx16<byte>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRx8<byte>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoBGR(this ReadOnlySpan<byte> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRx16<byte>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRx8<byte>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoBGR(this ReadOnlySpan<float> src, Span<XYZ> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRx16<float>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRx8<float>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoBGR(this ReadOnlySpan<float> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRx16<float>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRx8<float>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoRGBA(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRx4<byte>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRx2<byte>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = 255;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoRGBA(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRx4<byte>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRx2<byte>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = 255;
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoRGBA(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRx4<float>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRx2<float>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = 1;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoRGBA(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRx4<float>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRx2<float>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = 1;
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoBGRA(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRx4<byte>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRx2<byte>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = 255;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoBGRA(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRx4<byte>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRx2<byte>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = 255;
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoBGRA(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRx4<float>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRx2<float>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = 1;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoBGRA(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRx4<float>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRx2<float>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = 1;
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoARGB(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRx4<byte>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRx2<byte>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = 255;
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr.W = (float)src[0];
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoARGB(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRx4<byte>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRx2<byte>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = 255;
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr.W = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoARGB(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRx4<float>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRx2<float>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = 1;
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr.W = (float)src[0];
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRtoARGB(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 3 != 0) throw new ArgumentException("length is not multiple of 3", nameof(src));
        if (src.Length > dst.Length * 3) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRx4<float>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRx2<float>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 3);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 3)
            {
                ref var curr = ref dst[0];
                curr.X = 1;
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr.W = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(3);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoRGB(this ReadOnlySpan<byte> src, Span<XYZ> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBAx16<byte>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBAx8<byte>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoRGB(this ReadOnlySpan<byte> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBAx16<byte>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBAx8<byte>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoRGB(this ReadOnlySpan<float> src, Span<XYZ> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBAx16<float>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBAx8<float>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoRGB(this ReadOnlySpan<float> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBAx16<float>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBAx8<float>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoBGR(this ReadOnlySpan<byte> src, Span<XYZ> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBAx16<byte>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBAx8<byte>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoBGR(this ReadOnlySpan<byte> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBAx16<byte>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBAx8<byte>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoBGR(this ReadOnlySpan<float> src, Span<XYZ> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBAx16<float>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBAx8<float>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoBGR(this ReadOnlySpan<float> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __RGBAx16<float>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __RGBAx8<float>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoRGBA(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBAx4<byte>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBAx2<byte>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = (float)src[3];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoRGBA(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBAx4<byte>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBAx2<byte>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = (float)src[3];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoRGBA(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBAx4<float>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBAx2<float>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = (float)src[3];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoRGBA(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBAx4<float>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBAx2<float>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = (float)src[3];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoBGRA(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBAx4<byte>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBAx2<byte>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = (float)src[3];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoBGRA(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBAx4<byte>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBAx2<byte>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = (float)src[3];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoBGRA(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBAx4<float>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBAx2<float>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = (float)src[3];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoBGRA(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBAx4<float>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBAx2<float>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = (float)src[3];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoARGB(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBAx4<byte>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBAx2<byte>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[0];
                curr.Z = (float)src[1];
                curr.W = (float)src[2];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoARGB(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBAx4<byte>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__RGBAx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBAx2<byte>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[0];
                curr.Z = (float)src[1];
                curr.W = (float)src[2];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoARGB(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBAx4<float>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBAx2<float>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[0];
                curr.Z = (float)src[1];
                curr.W = (float)src[2];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertRGBAtoARGB(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __RGBAx4<float>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__RGBAx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __RGBAx2<float>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[0];
                curr.Z = (float)src[1];
                curr.W = (float)src[2];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoRGB(this ReadOnlySpan<byte> src, Span<XYZ> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRAx16<byte>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRAx8<byte>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoRGB(this ReadOnlySpan<byte> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRAx16<byte>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRAx8<byte>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoRGB(this ReadOnlySpan<float> src, Span<XYZ> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRAx16<float>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRAx8<float>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoRGB(this ReadOnlySpan<float> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRAx16<float>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRAx8<float>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoBGR(this ReadOnlySpan<byte> src, Span<XYZ> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRAx16<byte>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRAx8<byte>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoBGR(this ReadOnlySpan<byte> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRAx16<byte>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRAx8<byte>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoBGR(this ReadOnlySpan<float> src, Span<XYZ> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRAx16<float>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRAx8<float>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoBGR(this ReadOnlySpan<float> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __BGRAx16<float>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __BGRAx8<float>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoRGBA(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRAx4<byte>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRAx2<byte>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = (float)src[3];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoRGBA(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRAx4<byte>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRAx2<byte>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = (float)src[3];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoRGBA(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRAx4<float>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRAx2<float>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = (float)src[3];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoRGBA(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRAx4<float>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRAx2<float>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[2];
                curr.Y = (float)src[1];
                curr.Z = (float)src[0];
                curr.W = (float)src[3];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoBGRA(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRAx4<byte>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRAx2<byte>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = (float)src[3];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoBGRA(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRAx4<byte>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRAx2<byte>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = (float)src[3];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoBGRA(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRAx4<float>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRAx2<float>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = (float)src[3];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoBGRA(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRAx4<float>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRAx2<float>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = (float)src[3];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoARGB(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRAx4<byte>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRAx2<byte>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr.W = (float)src[0];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoARGB(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRAx4<byte>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__BGRAx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRAx2<byte>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr.W = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoARGB(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRAx4<float>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRAx2<float>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr.W = (float)src[0];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertBGRAtoARGB(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __BGRAx4<float>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__BGRAx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __BGRAx2<float>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr.W = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoRGB(this ReadOnlySpan<byte> src, Span<XYZ> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __ARGBx16<byte>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __ARGBx8<byte>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[1];
                curr.Y = (float)src[2];
                curr.Z = (float)src[3];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoRGB(this ReadOnlySpan<byte> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __ARGBx16<byte>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __ARGBx8<byte>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[1];
                curr.Y = (float)src[2];
                curr.Z = (float)src[3];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoRGB(this ReadOnlySpan<float> src, Span<XYZ> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __ARGBx16<float>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __ARGBx8<float>.CopyToRGB(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[1];
                curr.Y = (float)src[2];
                curr.Z = (float)src[3];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoRGB(this ReadOnlySpan<float> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __ARGBx16<float>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __ARGBx8<float>.CopyToRGB(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[1];
                curr.Y = (float)src[2];
                curr.Z = (float)src[3];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoBGR(this ReadOnlySpan<byte> src, Span<XYZ> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __ARGBx16<byte>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __ARGBx8<byte>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoBGR(this ReadOnlySpan<byte> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx16<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __ARGBx16<byte>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx8<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __ARGBx8<byte>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoBGR(this ReadOnlySpan<float> src, Span<XYZ> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __ARGBx16<float>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __ARGBx8<float>.CopyToBGR(srcX, dstX);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoBGR(this ReadOnlySpan<float> src, Span<XYZ> dst, in XYZ mul, in XYZ add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx16<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR16>(dst);
            __ARGBx16<float>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 16;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx8<float>>(src);
            var dstX = MMARSHALL.Cast<XYZ,VECTOR8>(dst);
            __ARGBx8<float>.CopyToBGR(srcX, dstX, mul, add);
            var len = srcX.Length * 8;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoRGBA(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __ARGBx4<byte>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __ARGBx2<byte>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[1];
                curr.Y = (float)src[2];
                curr.Z = (float)src[3];
                curr.W = (float)src[0];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoRGBA(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __ARGBx4<byte>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __ARGBx2<byte>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[1];
                curr.Y = (float)src[2];
                curr.Z = (float)src[3];
                curr.W = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoRGBA(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __ARGBx4<float>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __ARGBx2<float>.CopyToRGBA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[1];
                curr.Y = (float)src[2];
                curr.Z = (float)src[3];
                curr.W = (float)src[0];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoRGBA(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __ARGBx4<float>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __ARGBx2<float>.CopyToRGBA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[1];
                curr.Y = (float)src[2];
                curr.Z = (float)src[3];
                curr.W = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoBGRA(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __ARGBx4<byte>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __ARGBx2<byte>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr.W = (float)src[0];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoBGRA(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __ARGBx4<byte>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __ARGBx2<byte>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr.W = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoBGRA(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __ARGBx4<float>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __ARGBx2<float>.CopyToBGRA(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr.W = (float)src[0];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoBGRA(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __ARGBx4<float>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __ARGBx2<float>.CopyToBGRA(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[3];
                curr.Y = (float)src[2];
                curr.Z = (float)src[1];
                curr.W = (float)src[0];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoARGB(this ReadOnlySpan<byte> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __ARGBx4<byte>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __ARGBx2<byte>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = (float)src[3];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoARGB(this ReadOnlySpan<byte> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx4<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __ARGBx4<byte>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<byte,__ARGBx2<byte>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __ARGBx2<byte>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = (float)src[3];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoARGB(this ReadOnlySpan<float> src, Span<XYZW> dst)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __ARGBx4<float>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __ARGBx2<float>.CopyToARGB(srcX, dstX);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = (float)src[3];
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    /// <remarks>Copies <paramref name="src"/> into <paramref name="dst"/>, applying the appropiate color conversion.</remarks>
    public static void ConvertARGBtoARGB(this ReadOnlySpan<float> src, Span<XYZW> dst, in XYZW mul, in XYZW add)
    {
        if (src.Length % 4 != 0) throw new ArgumentException("length is not multiple of 4", nameof(src));
        if (src.Length > dst.Length * 4) throw new ArgumentOutOfRangeException(nameof(src));

        #if NET8_0_OR_GREATER
        if (false) {}
        else if (Vector512.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx4<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR16>(dst);
            __ARGBx4<float>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 4;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        else if (Vector256.IsHardwareAccelerated)
        {
            var srcX = MMARSHALL.Cast<float,__ARGBx2<float>>(src);
            var dstX = MMARSHALL.Cast<XYZW,VECTOR8>(dst);
            __ARGBx2<float>.CopyToARGB(srcX, dstX, mul, add);
            var len = srcX.Length * 2;
            src = src.Slice(len * 4);
            dst = dst.Slice(len);
        }

        #endif
        // fallback
        {
            while(src.Length >= 4)
            {
                ref var curr = ref dst[0];
                curr.X = (float)src[0];
                curr.Y = (float)src[1];
                curr.Z = (float)src[2];
                curr.W = (float)src[3];
                curr *= mul;
                curr += add;
                src = src.Slice(4);
                dst = dst.Slice(1);
            }
        }
    }

    #endregion

    
    }
}