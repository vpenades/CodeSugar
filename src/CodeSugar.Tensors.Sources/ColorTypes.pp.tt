<#@ template language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="ColorTypes.CodeGen.t4" #>
// <auto-generated />
// Copyright (c) CodeSugar 2024 Vicente Penades

using System;
using System.Numerics;
using System.Numerics.Tensors;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

#if NET
using System.Runtime.Intrinsics;
#endif

#if NET6_0_OR_GREATER
using VECTOR2FACTORY = System.Runtime.Intrinsics.Vector64;
using VECTOR4FACTORY = System.Runtime.Intrinsics.Vector128;
using VECTOR8FACTORY = System.Runtime.Intrinsics.Vector256;

using VECTOR2 = System.Runtime.Intrinsics.Vector64<float>;
using VECTOR4 = System.Runtime.Intrinsics.Vector128<float>;
using VECTOR8 = System.Runtime.Intrinsics.Vector256<float>;

#endif

#if NET8_0_OR_GREATER
using VECTOR16FACTORY = System.Runtime.Intrinsics.Vector512;

using VECTOR16 = System.Runtime.Intrinsics.Vector512<float>;
#endif

#nullable disable

using MMARSHALL = System.Runtime.InteropServices.MemoryMarshal;
using XYZ = System.Numerics.Vector3;
using XYZW = System.Numerics.Vector4;

#if CODESUGAR_USECODESUGARNAMESPACE
namespace CodeSugar
#elif CODESUGAR_USESYSTEMNAMESPACE
namespace System.Numerics
#else
namespace $rootnamespace$
#endif
{
    partial class CodeSugarForTensors
    {

    <#

    void _WriteLineEx(string line)    
    {
        switch(line)
        {
            case "{": WriteLine("{"); PushIndent("    "); break;
            case "}": PopIndent(); WriteLine("}"); break;
            default: WriteLine(line); break;     
        }
    }

    var formats = new string[] {"RGB","BGR","RGBA", "BGRA", "ARGB"};

    PushIndent("    ");

    // define the conversion helper structures

    WriteLine("#region support structures");

    var helpers = new Dictionary<(string src, string dst, int vsize),int>();

    foreach(var _srcColorType in formats)
    {
        WriteLine("");
        WriteLine($"#region {_srcColorType}");
        
        foreach(int structSize in new int[] {2, 4, 8, 16})
        {
            var structsWriter = new ColorConversionStructuresCodeGen(_WriteLineEx, _srcColorType, structSize);

            structsWriter.WriteStructBegin();

            // add the -compatible- vector SIMD conversion functions

            

            foreach(var _dstColorType in formats)                
            {
                structsWriter.WriteConverter("byte", _dstColorType, 1);
                structsWriter.WriteConverter("float", _dstColorType, 1);

                structsWriter.WriteConverter("byte", _dstColorType, 3);
                structsWriter.WriteConverter("float", _dstColorType, 3);
            }            

            foreach(var kvp in structsWriter.AvailableConverters)     
            {
                helpers[(_srcColorType, kvp.Key , kvp.Value.size)] = structSize;

                structsWriter.WriteMethod(kvp.Key, kvp.Value.size, kvp.Value.repeats, false);
                structsWriter.WriteMethod(kvp.Key, kvp.Value.size, kvp.Value.repeats, true);
            }

            structsWriter.WriteStructEnd();
        }
        
        WriteLine("");
        WriteLine("#endregion");        
    }
    
    WriteLine("");
    WriteLine("#endregion");
    WriteLine("");

    // define public functions

    WriteLine("#region public methods");

    /*
    foreach(var kvp in helpers)
    {
        WriteLine($"// {kvp.Key}   __{kvp.Key.src}x{kvp.Value}");
    }*/

    

    
    foreach(var _srcColorType in formats)
    {
        foreach(var _dstColorType in formats)                        
        {
            var funcsWriter = new ColorConversionStaticFuncCodeGen(_WriteLineEx, _srcColorType, _dstColorType, helpers);
                        
            funcsWriter.WriteStaticMethod("byte", false);
            funcsWriter.WriteStaticMethod("byte", true);

            funcsWriter.WriteStaticMethod("float", false);
            funcsWriter.WriteStaticMethod("float", true);
        }
    }

    WriteLine("");
    WriteLine("#endregion");
    WriteLine("");

    PopIndent();

    #>
    
    }
}